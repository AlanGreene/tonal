[
  {
    "description": "Get a set binary number from a collection of notes or intervals\n\nA set binary number is a 12 digit binary, each digit representing a step\nin the chromatic scale. For example, `101010000000` is `['1P', '2M', '3M']`\n\nThe set binary number is very useful to check if two sets are equal or\ncontains same intervals (regarding of note names)",
    "tags": [
      {
        "title": "name",
        "description": null,
        "lineNumber": 9,
        "name": "binarySet.toBinary"
      },
      {
        "title": "function",
        "description": null,
        "lineNumber": 10,
        "name": null
      },
      {
        "title": "param",
        "description": "a gamut",
        "lineNumber": 12,
        "type": {
          "type": "UnionType",
          "elements": [
            {
              "type": "NameExpression",
              "name": "String"
            },
            {
              "type": "NameExpression",
              "name": "Array"
            },
            {
              "type": "TypeApplication",
              "expression": {
                "type": "NameExpression",
                "name": "Array"
              },
              "applications": [
                {
                  "type": "NameExpression",
                  "name": "Array"
                }
              ]
            }
          ]
        },
        "name": "source"
      },
      {
        "title": "returns",
        "description": "the binary number",
        "lineNumber": 13,
        "type": {
          "type": "NameExpression",
          "name": "String"
        }
      },
      {
        "title": "example",
        "description": "var binarySet = require('binary-set')\nbinarySet.toBinary('C2 E4 D3') // => '101010000000'",
        "lineNumber": 15
      },
      {
        "title": "kind",
        "kind": "function"
      },
      {
        "title": "memberof",
        "description": "bs"
      },
      {
        "title": "static"
      }
    ],
    "loc": {
      "start": {
        "line": 9,
        "column": 0
      },
      "end": {
        "line": 26,
        "column": 3
      }
    },
    "context": {
      "loc": {
        "start": {
          "line": 27,
          "column": 0
        },
        "end": {
          "line": 36,
          "column": 0
        }
      },
      "file": "./packages/binary-set/index.js",
      "code": "'use strict'\n\nvar set = require('pitch-set')\nvar transpose = require('note-transposer')\nvar semitones = require('semitones')\n\nvar bs = {}\n\n/**\n * Get a set binary number from a collection of notes or intervals\n *\n * A set binary number is a 12 digit binary, each digit representing a step\n * in the chromatic scale. For example, `101010000000` is `['1P', '2M', '3M']`\n *\n * The set binary number is very useful to check if two sets are equal or\n * contains same intervals (regarding of note names)\n *\n * @name binarySet.toBinary\n * @function\n * @param {String|Array|Array<Array>} source - a gamut\n * @return {String} the binary number\n *\n * @example\n * var binarySet = require('binary-set')\n * binarySet.toBinary('C2 E4 D3') // => '101010000000'\n */\nbs.toBinary = function (gamut) {\n  var number = [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]\n  var sizes = set(gamut, false).map(semitones)\n  sizes.forEach(function (s) {\n    number[s] = 1\n  })\n  return number.join('')\n}\n\nvar INTERVALS = ['1P', '2m', '2M', '3m', '3M', '4P', '4#', '5P', '6m', '6M', '7m', '7M']\n\n/**\n * Get a set from a binary set number and (optionally) a tonic. If the tonic is\n * a note, you get a pitch set. If its false you get a interval set.\n *\n * @name set.fromBinary\n * @function\n * @param {String|Array|Array<Array>} source - the gamut\n * @param {String} tonic - the first note of the set or false to get the intervals\n * @return {Array<String>} the set pitch classes (note names without octaves)\n *\n * @example\n * var fromBinary = require('tonal.set/fromBinary')\n * // use a 12 digit binary number:\n * fromBinary('101011010101', 'C') // => ['C', 'D', 'E', 'F', 'G', 'A', 'B']\n * // or its decimal equivalent:\n * fromBinary(2773, 'C') // => ['C', 'D', 'E', 'F', 'G', 'A', 'B']\n * // get the interval set by passing `false` as tonic:\n * fromBinary(2773, false) // => ['1P', '2M', '3M', '4', '5', '6M', '7M']\n */\nbs.fromBinary = function (number, tonic) {\n  if (arguments.length === 1) return function (t) { return bs.fromBinary(number, t) }\n\n  if (/^1[01]{11}$/.test(number)) number = parseInt(number, 2)\n  else if (typeof number !== 'number') return []\n  var binary = ((number % 2048) + 2048).toString(2)\n\n  var set = []\n  for (var i = 0; i < 12; i++) {\n    if (binary.charAt(i) === '1') {\n      if (i === 6 && binary.charAt(5) === '1') set.push('5d')\n      else set.push(INTERVALS[i])\n    }\n  }\n  return tonic === false ? set : set.map(transpose(tonic))\n}\n\nmodule.exports = bs\n"
    },
    "name": "binarySet.toBinary",
    "params": [
      {
        "title": "param",
        "description": "a gamut",
        "lineNumber": 12,
        "type": {
          "type": "UnionType",
          "elements": [
            {
              "type": "NameExpression",
              "name": "String"
            },
            {
              "type": "NameExpression",
              "name": "Array"
            },
            {
              "type": "TypeApplication",
              "expression": {
                "type": "NameExpression",
                "name": "Array"
              },
              "applications": [
                {
                  "type": "NameExpression",
                  "name": "Array"
                }
              ]
            }
          ]
        },
        "name": "source"
      }
    ],
    "returns": [
      {
        "title": "returns",
        "description": "the binary number",
        "lineNumber": 13,
        "type": {
          "type": "NameExpression",
          "name": "String"
        }
      }
    ],
    "examples": [
      "<span class=\"hljs-keyword\">var</span> binarySet = <span class=\"hljs-built_in\">require</span>(<span class=\"hljs-string\">'binary-set'</span>)\nbinarySet.toBinary(<span class=\"hljs-string\">'C2 E4 D3'</span>) <span class=\"hljs-comment\">// =&gt; '101010000000'</span>"
    ],
    "kind": "function",
    "memberof": "bs",
    "scope": "static",
    "members": {
      "instance": [],
      "static": []
    },
    "events": [],
    "path": [
      "binarySet.toBinary"
    ]
  },
  {
    "description": "Create chords either by name or by intervals\n\nThis function is currified",
    "tags": [
      {
        "title": "name",
        "description": null,
        "lineNumber": 5,
        "name": "chord"
      },
      {
        "title": "function",
        "description": null,
        "lineNumber": 6,
        "name": null
      },
      {
        "title": "param",
        "description": "the chord name, intervals or notes",
        "lineNumber": 8,
        "type": {
          "type": "NameExpression",
          "name": "String"
        },
        "name": "source"
      },
      {
        "title": "param",
        "description": "the chord tonic",
        "lineNumber": 9,
        "type": {
          "type": "NameExpression",
          "name": "String"
        },
        "name": "tonic"
      },
      {
        "title": "returns",
        "description": "the chord notes",
        "lineNumber": 10,
        "type": {
          "type": "NameExpression",
          "name": "Array"
        }
      },
      {
        "title": "example",
        "description": "var chord = require('music-chord')\n// create chord from name\nchord('Cmaj7') // => ['C', 'E', 'G', 'B']\nchord('maj7', 'C') // => ['C', 'E', 'G', 'B']",
        "lineNumber": 12
      },
      {
        "title": "example",
        "description": "// partially applied\nvar maj7 = chord('maj7')\nmaj7('C') // => ['C', 'E', 'G', 'B']",
        "lineNumber": 18
      },
      {
        "title": "example",
        "description": "// create chord from intervals\nchord('1 3 5 7', 'C') // => ['C', 'E', 'G', 'B']",
        "lineNumber": 23
      },
      {
        "title": "kind",
        "kind": "function"
      }
    ],
    "loc": {
      "start": {
        "line": 6,
        "column": 0
      },
      "end": {
        "line": 31,
        "column": 3
      }
    },
    "context": {
      "loc": {
        "start": {
          "line": 32,
          "column": 0
        },
        "end": {
          "line": 40,
          "column": 1
        }
      },
      "file": "./packages/music-chord/index.js",
      "code": "'use strict'\n\nvar harmonizer = require('note-harmonizer')\nvar dictionary = require('chord-dictionary')\n\n/**\n * Create chords either by name or by intervals\n *\n * This function is currified\n *\n * @name chord\n * @function\n * @param {String} source - the chord name, intervals or notes\n * @param {String} tonic - the chord tonic\n * @return {Array} the chord notes\n *\n * @example\n * var chord = require('music-chord')\n * // create chord from name\n * chord('Cmaj7') // => ['C', 'E', 'G', 'B']\n * chord('maj7', 'C') // => ['C', 'E', 'G', 'B']\n *\n * @example\n * // partially applied\n * var maj7 = chord('maj7')\n * maj7('C') // => ['C', 'E', 'G', 'B']\n *\n * @example\n * // create chord from intervals\n * chord('1 3 5 7', 'C') // => ['C', 'E', 'G', 'B']\n */\nfunction chord (source, tonic) {\n  var c\n  if (arguments.length === 1) {\n    c = dictionary(source)\n    return typeof c === 'function' ? function (t) { return chord(source, t) } : c\n  }\n  c = dictionary(source, tonic)\n  return c.length ? c : harmonizer(source, tonic)\n}\n\n/**\n * Get available chord names\n * @name chord.names\n * @function\n * @param {Boolean} aliases - if true, it returns the name aliases\n * @return {Array} the available chord names\n */\nchord.names = dictionary.names\n\n/**\n * Get chord properties\n *\n * @name chord.props\n * @function\n * @param {String} name - the chord name\n * @return {Object} the chord properties\n */\nchord.props = dictionary.props\n\nif (typeof module === 'object' && module.exports) module.exports = chord\nif (typeof window !== 'undefined') window.chord = chord\n"
    },
    "name": "chord",
    "params": [
      {
        "title": "param",
        "description": "the chord name, intervals or notes",
        "lineNumber": 8,
        "type": {
          "type": "NameExpression",
          "name": "String"
        },
        "name": "source"
      },
      {
        "title": "param",
        "description": "the chord tonic",
        "lineNumber": 9,
        "type": {
          "type": "NameExpression",
          "name": "String"
        },
        "name": "tonic"
      }
    ],
    "returns": [
      {
        "title": "returns",
        "description": "the chord notes",
        "lineNumber": 10,
        "type": {
          "type": "NameExpression",
          "name": "Array"
        }
      }
    ],
    "examples": [
      "<span class=\"hljs-keyword\">var</span> chord = <span class=\"hljs-built_in\">require</span>(<span class=\"hljs-string\">'music-chord'</span>)\n<span class=\"hljs-comment\">// create chord from name</span>\nchord(<span class=\"hljs-string\">'Cmaj7'</span>) <span class=\"hljs-comment\">// =&gt; ['C', 'E', 'G', 'B']</span>\nchord(<span class=\"hljs-string\">'maj7'</span>, <span class=\"hljs-string\">'C'</span>) <span class=\"hljs-comment\">// =&gt; ['C', 'E', 'G', 'B']</span>",
      "<span class=\"hljs-comment\">// partially applied</span>\n<span class=\"hljs-keyword\">var</span> maj7 = chord(<span class=\"hljs-string\">'maj7'</span>)\nmaj7(<span class=\"hljs-string\">'C'</span>) <span class=\"hljs-comment\">// =&gt; ['C', 'E', 'G', 'B']</span>",
      "<span class=\"hljs-comment\">// create chord from intervals</span>\nchord(<span class=\"hljs-string\">'1 3 5 7'</span>, <span class=\"hljs-string\">'C'</span>) <span class=\"hljs-comment\">// =&gt; ['C', 'E', 'G', 'B']</span>"
    ],
    "kind": "function",
    "members": {
      "instance": [],
      "static": [
        {
          "description": "Get available chord names",
          "tags": [
            {
              "title": "name",
              "description": null,
              "lineNumber": 2,
              "name": "chord.names"
            },
            {
              "title": "function",
              "description": null,
              "lineNumber": 3,
              "name": null
            },
            {
              "title": "param",
              "description": "if true, it returns the name aliases",
              "lineNumber": 5,
              "type": {
                "type": "NameExpression",
                "name": "Boolean"
              },
              "name": "aliases"
            },
            {
              "title": "returns",
              "description": "the available chord names",
              "lineNumber": 6,
              "type": {
                "type": "NameExpression",
                "name": "Array"
              }
            },
            {
              "title": "kind",
              "kind": "function"
            },
            {
              "title": "memberof",
              "description": "chord"
            },
            {
              "title": "static"
            }
          ],
          "loc": {
            "start": {
              "line": 42,
              "column": 0
            },
            "end": {
              "line": 48,
              "column": 3
            }
          },
          "context": {
            "loc": {
              "start": {
                "line": 49,
                "column": 0
              },
              "end": {
                "line": 59,
                "column": 0
              }
            },
            "file": "./packages/music-chord/index.js",
            "code": "'use strict'\n\nvar harmonizer = require('note-harmonizer')\nvar dictionary = require('chord-dictionary')\n\n/**\n * Create chords either by name or by intervals\n *\n * This function is currified\n *\n * @name chord\n * @function\n * @param {String} source - the chord name, intervals or notes\n * @param {String} tonic - the chord tonic\n * @return {Array} the chord notes\n *\n * @example\n * var chord = require('music-chord')\n * // create chord from name\n * chord('Cmaj7') // => ['C', 'E', 'G', 'B']\n * chord('maj7', 'C') // => ['C', 'E', 'G', 'B']\n *\n * @example\n * // partially applied\n * var maj7 = chord('maj7')\n * maj7('C') // => ['C', 'E', 'G', 'B']\n *\n * @example\n * // create chord from intervals\n * chord('1 3 5 7', 'C') // => ['C', 'E', 'G', 'B']\n */\nfunction chord (source, tonic) {\n  var c\n  if (arguments.length === 1) {\n    c = dictionary(source)\n    return typeof c === 'function' ? function (t) { return chord(source, t) } : c\n  }\n  c = dictionary(source, tonic)\n  return c.length ? c : harmonizer(source, tonic)\n}\n\n/**\n * Get available chord names\n * @name chord.names\n * @function\n * @param {Boolean} aliases - if true, it returns the name aliases\n * @return {Array} the available chord names\n */\nchord.names = dictionary.names\n\n/**\n * Get chord properties\n *\n * @name chord.props\n * @function\n * @param {String} name - the chord name\n * @return {Object} the chord properties\n */\nchord.props = dictionary.props\n\nif (typeof module === 'object' && module.exports) module.exports = chord\nif (typeof window !== 'undefined') window.chord = chord\n"
          },
          "name": "chord.names",
          "params": [
            {
              "title": "param",
              "description": "if true, it returns the name aliases",
              "lineNumber": 5,
              "type": {
                "type": "NameExpression",
                "name": "Boolean"
              },
              "name": "aliases"
            }
          ],
          "returns": [
            {
              "title": "returns",
              "description": "the available chord names",
              "lineNumber": 6,
              "type": {
                "type": "NameExpression",
                "name": "Array"
              }
            }
          ],
          "kind": "function",
          "memberof": "chord",
          "scope": "static",
          "members": {
            "instance": [],
            "static": []
          },
          "events": [],
          "path": [
            "chord",
            "chord.names"
          ]
        },
        {
          "description": "Get chord properties",
          "tags": [
            {
              "title": "name",
              "description": null,
              "lineNumber": 3,
              "name": "chord.props"
            },
            {
              "title": "function",
              "description": null,
              "lineNumber": 4,
              "name": null
            },
            {
              "title": "param",
              "description": "the chord name",
              "lineNumber": 6,
              "type": {
                "type": "NameExpression",
                "name": "String"
              },
              "name": "name"
            },
            {
              "title": "returns",
              "description": "the chord properties",
              "lineNumber": 7,
              "type": {
                "type": "NameExpression",
                "name": "Object"
              }
            },
            {
              "title": "kind",
              "kind": "function"
            },
            {
              "title": "memberof",
              "description": "chord"
            },
            {
              "title": "static"
            }
          ],
          "loc": {
            "start": {
              "line": 51,
              "column": 0
            },
            "end": {
              "line": 58,
              "column": 3
            }
          },
          "context": {
            "loc": {
              "start": {
                "line": 59,
                "column": 0
              },
              "end": {
                "line": 61,
                "column": 0
              }
            },
            "file": "./packages/music-chord/index.js",
            "code": "'use strict'\n\nvar harmonizer = require('note-harmonizer')\nvar dictionary = require('chord-dictionary')\n\n/**\n * Create chords either by name or by intervals\n *\n * This function is currified\n *\n * @name chord\n * @function\n * @param {String} source - the chord name, intervals or notes\n * @param {String} tonic - the chord tonic\n * @return {Array} the chord notes\n *\n * @example\n * var chord = require('music-chord')\n * // create chord from name\n * chord('Cmaj7') // => ['C', 'E', 'G', 'B']\n * chord('maj7', 'C') // => ['C', 'E', 'G', 'B']\n *\n * @example\n * // partially applied\n * var maj7 = chord('maj7')\n * maj7('C') // => ['C', 'E', 'G', 'B']\n *\n * @example\n * // create chord from intervals\n * chord('1 3 5 7', 'C') // => ['C', 'E', 'G', 'B']\n */\nfunction chord (source, tonic) {\n  var c\n  if (arguments.length === 1) {\n    c = dictionary(source)\n    return typeof c === 'function' ? function (t) { return chord(source, t) } : c\n  }\n  c = dictionary(source, tonic)\n  return c.length ? c : harmonizer(source, tonic)\n}\n\n/**\n * Get available chord names\n * @name chord.names\n * @function\n * @param {Boolean} aliases - if true, it returns the name aliases\n * @return {Array} the available chord names\n */\nchord.names = dictionary.names\n\n/**\n * Get chord properties\n *\n * @name chord.props\n * @function\n * @param {String} name - the chord name\n * @return {Object} the chord properties\n */\nchord.props = dictionary.props\n\nif (typeof module === 'object' && module.exports) module.exports = chord\nif (typeof window !== 'undefined') window.chord = chord\n"
          },
          "name": "chord.props",
          "params": [
            {
              "title": "param",
              "description": "the chord name",
              "lineNumber": 6,
              "type": {
                "type": "NameExpression",
                "name": "String"
              },
              "name": "name"
            }
          ],
          "returns": [
            {
              "title": "returns",
              "description": "the chord properties",
              "lineNumber": 7,
              "type": {
                "type": "NameExpression",
                "name": "Object"
              }
            }
          ],
          "kind": "function",
          "memberof": "chord",
          "scope": "static",
          "members": {
            "instance": [],
            "static": []
          },
          "events": [],
          "path": [
            "chord",
            "chord.props"
          ]
        }
      ]
    },
    "events": [],
    "path": [
      "chord"
    ]
  },
  {
    "description": "A chord dictionary. Get chord data from a chord name.",
    "tags": [
      {
        "title": "name",
        "description": null,
        "lineNumber": 3,
        "name": "chord"
      },
      {
        "title": "function",
        "description": null,
        "lineNumber": 4,
        "name": null
      },
      {
        "title": "param",
        "description": "the chord name",
        "lineNumber": 6,
        "type": {
          "type": "NameExpression",
          "name": "String"
        },
        "name": "name"
      },
      {
        "title": "see",
        "description": "music-dictionary",
        "lineNumber": 7
      },
      {
        "title": "example",
        "description": "var chord = require('chord-dictionary')\n\n// get chord notes and intervals\nchord('CMaj7') // => ['C', 'E', 'G', 'B']\nchord('Maj7', 'C') // => ['C', 'E', 'G', 'B']\nchord('Maj7') // => ['P1', 'M3', 'P5', 'M7']",
        "lineNumber": 9
      },
      {
        "title": "example",
        "description": "// get chord properties\nchord.props('Maj7') // => { name: 'Maj7', aliases: ['M7', 'maj7']\n               //      intervals:  [ ...],\n               //      binary: '100010010001', decimal: 2193 }",
        "lineNumber": 17
      },
      {
        "title": "example",
        "description": "// get it from aliases, binary or decimal numbers\nchord('Maj7') === chord('M7') === chord('100010010001') === chord(2913)",
        "lineNumber": 23
      },
      {
        "title": "example",
        "description": "// get chord names\nchord.names // => ['Maj7', 'm7', ...]",
        "lineNumber": 27
      },
      {
        "title": "kind",
        "kind": "function"
      },
      {
        "title": "memberof",
        "description": "module"
      },
      {
        "title": "static"
      }
    ],
    "loc": {
      "start": {
        "line": 6,
        "column": 0
      },
      "end": {
        "line": 35,
        "column": 3
      }
    },
    "context": {
      "loc": {
        "start": {
          "line": 36,
          "column": 0
        },
        "end": {
          "line": 37,
          "column": 0
        }
      },
      "file": "./packages/chord-dictionary/index.js",
      "code": "'use strict'\n\nvar chords = require('./chords.json')\nvar dictionary = require('music-dictionary')\n\n/**\n * A chord dictionary. Get chord data from a chord name.\n *\n * @name chord\n * @function\n * @param {String} name - the chord name\n * @see music-dictionary\n *\n * @example\n * var chord = require('chord-dictionary')\n *\n * // get chord notes and intervals\n * chord('CMaj7') // => ['C', 'E', 'G', 'B']\n * chord('Maj7', 'C') // => ['C', 'E', 'G', 'B']\n * chord('Maj7') // => ['P1', 'M3', 'P5', 'M7']\n *\n * @example\n * // get chord properties\n * chord.props('Maj7') // => { name: 'Maj7', aliases: ['M7', 'maj7']\n *                //      intervals:  [ ...],\n *                //      binary: '100010010001', decimal: 2193 }\n *\n * @example\n * // get it from aliases, binary or decimal numbers\n * chord('Maj7') === chord('M7') === chord('100010010001') === chord(2913)\n *\n * @example\n * // get chord names\n * chord.names // => ['Maj7', 'm7', ...]\n */\nmodule.exports = dictionary(chords)\n"
    },
    "name": "chord",
    "params": [
      {
        "title": "param",
        "description": "the chord name",
        "lineNumber": 6,
        "type": {
          "type": "NameExpression",
          "name": "String"
        },
        "name": "name"
      }
    ],
    "examples": [
      "<span class=\"hljs-keyword\">var</span> chord = <span class=\"hljs-built_in\">require</span>(<span class=\"hljs-string\">'chord-dictionary'</span>)\n\n<span class=\"hljs-comment\">// get chord notes and intervals</span>\nchord(<span class=\"hljs-string\">'CMaj7'</span>) <span class=\"hljs-comment\">// =&gt; ['C', 'E', 'G', 'B']</span>\nchord(<span class=\"hljs-string\">'Maj7'</span>, <span class=\"hljs-string\">'C'</span>) <span class=\"hljs-comment\">// =&gt; ['C', 'E', 'G', 'B']</span>\nchord(<span class=\"hljs-string\">'Maj7'</span>) <span class=\"hljs-comment\">// =&gt; ['P1', 'M3', 'P5', 'M7']</span>",
      "<span class=\"hljs-comment\">// get chord properties</span>\nchord.props(<span class=\"hljs-string\">'Maj7'</span>) <span class=\"hljs-comment\">// =&gt; { name: 'Maj7', aliases: ['M7', 'maj7']</span>\n               <span class=\"hljs-comment\">//      intervals:  [ ...],</span>\n               <span class=\"hljs-comment\">//      binary: '100010010001', decimal: 2193 }</span>",
      "<span class=\"hljs-comment\">// get it from aliases, binary or decimal numbers</span>\nchord(<span class=\"hljs-string\">'Maj7'</span>) === chord(<span class=\"hljs-string\">'M7'</span>) === chord(<span class=\"hljs-string\">'100010010001'</span>) === chord(<span class=\"hljs-number\">2913</span>)",
      "<span class=\"hljs-comment\">// get chord names</span>\nchord.names <span class=\"hljs-comment\">// =&gt; ['Maj7', 'm7', ...]</span>"
    ],
    "kind": "function",
    "memberof": "module",
    "scope": "static",
    "members": {
      "instance": [],
      "static": []
    },
    "events": [],
    "path": [
      "chord"
    ]
  },
  {
    "description": "Get chord progression from a tonic and roman numerals chords",
    "tags": [
      {
        "title": "name",
        "description": null,
        "lineNumber": 3,
        "name": "chord.progression"
      },
      {
        "title": "function",
        "description": null,
        "lineNumber": 4,
        "name": null
      },
      {
        "title": "param",
        "description": "the tonic",
        "lineNumber": 6,
        "type": {
          "type": "NameExpression",
          "name": "String"
        },
        "name": "tonic"
      },
      {
        "title": "param",
        "description": "the progression in roman numerals",
        "lineNumber": 7,
        "type": {
          "type": "UnionType",
          "elements": [
            {
              "type": "NameExpression",
              "name": "Array"
            },
            {
              "type": "NameExpression",
              "name": "String"
            }
          ]
        },
        "name": "progression"
      },
      {
        "title": "returns",
        "description": "the chord progression",
        "lineNumber": 8,
        "type": {
          "type": "NameExpression",
          "name": "Array"
        }
      },
      {
        "title": "example",
        "description": "var progression = require('chord-progression')\nprogression('C', 'I IIm7 V7') // => ['C', 'Dm7', 'G7']",
        "lineNumber": 10
      },
      {
        "title": "kind",
        "kind": "function"
      },
      {
        "title": "memberof",
        "description": "module"
      },
      {
        "title": "static"
      }
    ],
    "loc": {
      "start": {
        "line": 8,
        "column": 0
      },
      "end": {
        "line": 20,
        "column": 3
      }
    },
    "context": {
      "loc": {
        "start": {
          "line": 21,
          "column": 0
        },
        "end": {
          "line": 30,
          "column": 0
        }
      },
      "file": "./packages/chord-progression/index.js",
      "code": "'use strict'\n\nvar gamut = require('music-gamut')\nvar regex = require('music-notation/roman/regex')\nvar parse = require('music-notation/roman/parse')\nvar transpose = require('note-transposer')\n\n/**\n * Get chord progression from a tonic and roman numerals chords\n *\n * @name chord.progression\n * @function\n * @param {String} tonic - the tonic\n * @param {Array|String} progression - the progression in roman numerals\n * @return {Array} the chord progression\n *\n * @example\n * var progression = require('chord-progression')\n * progression('C', 'I IIm7 V7') // => ['C', 'Dm7', 'G7']\n */\nmodule.exports = function (tonic, progression) {\n  return gamut.split(progression)\n    .map(function (e) { return regex.exec(e) })\n    .map(function (roman) {\n      if (!roman) return null\n      var pc = parse(roman[2])\n      return transpose(tonic, pc) + roman[3]\n    })\n}\n"
    },
    "name": "chord.progression",
    "params": [
      {
        "title": "param",
        "description": "the tonic",
        "lineNumber": 6,
        "type": {
          "type": "NameExpression",
          "name": "String"
        },
        "name": "tonic"
      },
      {
        "title": "param",
        "description": "the progression in roman numerals",
        "lineNumber": 7,
        "type": {
          "type": "UnionType",
          "elements": [
            {
              "type": "NameExpression",
              "name": "Array"
            },
            {
              "type": "NameExpression",
              "name": "String"
            }
          ]
        },
        "name": "progression"
      }
    ],
    "returns": [
      {
        "title": "returns",
        "description": "the chord progression",
        "lineNumber": 8,
        "type": {
          "type": "NameExpression",
          "name": "Array"
        }
      }
    ],
    "examples": [
      "<span class=\"hljs-keyword\">var</span> progression = <span class=\"hljs-built_in\">require</span>(<span class=\"hljs-string\">'chord-progression'</span>)\nprogression(<span class=\"hljs-string\">'C'</span>, <span class=\"hljs-string\">'I IIm7 V7'</span>) <span class=\"hljs-comment\">// =&gt; ['C', 'Dm7', 'G7']</span>"
    ],
    "kind": "function",
    "memberof": "module",
    "scope": "static",
    "members": {
      "instance": [],
      "static": []
    },
    "events": [],
    "path": [
      "chord.progression"
    ]
  },
  {
    "description": "Given a triad notes, get it's type (can be 'M', 'm', '7' or 'o' to represent major,\nminor, dominant and diminished respectively)\n\nIt assumes that the chord is not inverted (first note is always the tonic)\n\nIt detects major, minor, augmented, diminished and dominant chords. All\nchord notes beyond the 5th (except 7th for dominant chords) are ignored",
    "tags": [
      {
        "title": "name",
        "description": null,
        "lineNumber": 9,
        "name": "chord.type"
      },
      {
        "title": "function",
        "description": null,
        "lineNumber": 10,
        "name": null
      },
      {
        "title": "param",
        "description": "the chord notes",
        "lineNumber": 12,
        "type": {
          "type": "NameExpression",
          "name": "Array"
        },
        "name": "chord"
      },
      {
        "title": "returns",
        "description": "the chord type ('M', 'm', '7', 'dim', 'aug' or null)",
        "lineNumber": 13,
        "type": {
          "type": "NameExpression",
          "name": "String"
        }
      },
      {
        "title": "example",
        "description": "var type = require('chord-type')\ntype('C E G') // => 'M'\ntype('C Eb G') // => 'm'\ntype('C Eb Gb') // => 'dim'\ntype('C E G#') // => 'aug'\ntype('C E G B') // => 'M'\ntype('C E G B7') // => '7'",
        "lineNumber": 15
      },
      {
        "title": "kind",
        "kind": "function"
      },
      {
        "title": "memberof",
        "description": "module"
      },
      {
        "title": "static"
      }
    ],
    "loc": {
      "start": {
        "line": 5,
        "column": 0
      },
      "end": {
        "line": 27,
        "column": 3
      }
    },
    "context": {
      "loc": {
        "start": {
          "line": 28,
          "column": 0
        },
        "end": {
          "line": 41,
          "column": 0
        }
      },
      "file": "./packages/chord-type/index.js",
      "code": "'use strict'\n\nvar G = require('music-gamut')\n\n/**\n * Given a triad notes, get it's type (can be 'M', 'm', '7' or 'o' to represent major,\n * minor, dominant and diminished respectively)\n *\n * It assumes that the chord is not inverted (first note is always the tonic)\n *\n * It detects major, minor, augmented, diminished and dominant chords. All\n * chord notes beyond the 5th (except 7th for dominant chords) are ignored\n *\n * @name chord.type\n * @function\n * @param {Array} chord - the chord notes\n * @return {String} the chord type ('M', 'm', '7', 'dim', 'aug' or null)\n *\n * @example\n * var type = require('chord-type')\n * type('C E G') // => 'M'\n * type('C Eb G') // => 'm'\n * type('C Eb Gb') // => 'dim'\n * type('C E G#') // => 'aug'\n * type('C E G B') // => 'M'\n * type('C E G B7') // => '7'\n */\nmodule.exports = function (chord) {\n  var g = G.harmonizer(chord, false)\n  var steps = g.map(function (i) { return i ? i.charAt(0) : i })\n  if (steps[0] !== '1' || steps[2] !== '5') return null\n  if (g[1] === '3M') {\n    if (g[2] === '5A') return 'aug'\n    else return g[3] === '7m' ? '7' : 'M'\n  } else if (g[1] === '3m') {\n    return g[2] === '5P' ? 'm' : 'dim'\n  } else if (g[1] === '4P') {\n    return 'sus4'\n  }\n}\n"
    },
    "name": "chord.type",
    "params": [
      {
        "title": "param",
        "description": "the chord notes",
        "lineNumber": 12,
        "type": {
          "type": "NameExpression",
          "name": "Array"
        },
        "name": "chord"
      }
    ],
    "returns": [
      {
        "title": "returns",
        "description": "the chord type ('M', 'm', '7', 'dim', 'aug' or null)",
        "lineNumber": 13,
        "type": {
          "type": "NameExpression",
          "name": "String"
        }
      }
    ],
    "examples": [
      "<span class=\"hljs-keyword\">var</span> type = <span class=\"hljs-built_in\">require</span>(<span class=\"hljs-string\">'chord-type'</span>)\ntype(<span class=\"hljs-string\">'C E G'</span>) <span class=\"hljs-comment\">// =&gt; 'M'</span>\ntype(<span class=\"hljs-string\">'C Eb G'</span>) <span class=\"hljs-comment\">// =&gt; 'm'</span>\ntype(<span class=\"hljs-string\">'C Eb Gb'</span>) <span class=\"hljs-comment\">// =&gt; 'dim'</span>\ntype(<span class=\"hljs-string\">'C E G#'</span>) <span class=\"hljs-comment\">// =&gt; 'aug'</span>\ntype(<span class=\"hljs-string\">'C E G B'</span>) <span class=\"hljs-comment\">// =&gt; 'M'</span>\ntype(<span class=\"hljs-string\">'C E G B7'</span>) <span class=\"hljs-comment\">// =&gt; '7'</span>"
    ],
    "kind": "function",
    "memberof": "module",
    "scope": "static",
    "members": {
      "instance": [],
      "static": []
    },
    "events": [],
    "path": [
      "chord.type"
    ]
  },
  {
    "description": "Create a musical dictionary. A musical dictionary is a function that given\na name (and optionally a tonic) returns an array of notes.\n\nA dictionary is created from a HashMap. It maps a name to a string with\nan interval list and, optionally, an alternative name list (see example)\n\nAdditionally, the dictionary has properties (see examples):\n\n- data: a hash with the dictionary data\n- names: an array with all the names\n- aliases: an array with all the names including aliases\n- source: the source of the dictionary\n\nEach value of the data hash have the following properties:\n\n- name: the name\n- aliases: an array with the alternative names\n- intervals: an array with the intervals\n- steps: an array with the intervals in __array notation__\n- binary: a binary representation of the set\n- decimal: the decimal representation of the set",
    "tags": [
      {
        "title": "name",
        "description": null,
        "lineNumber": 23,
        "name": "dictionary"
      },
      {
        "title": "function",
        "description": null,
        "lineNumber": 24,
        "name": null
      },
      {
        "title": "param",
        "description": "the dictionary source",
        "lineNumber": 26,
        "type": {
          "type": "NameExpression",
          "name": "Hash"
        },
        "name": "source"
      },
      {
        "title": "returns",
        "description": "the dictionary",
        "lineNumber": 27,
        "type": {
          "type": "NameExpression",
          "name": "Function"
        }
      },
      {
        "title": "example",
        "description": "var dictionary = require('music-dictionary')\nvar chords = dictionary({'Maj7': ['1 3 5 7', ['M7']], 'm7': ['1 3b 5 7b'] })\nchords('CMaj7') // => ['C', 'E', 'G', 'B']\nchords('DM7') // => ['D', 'F#', 'A', 'C#']\nchords('Bm7') // => ['B', 'D', 'F#', 'A']",
        "lineNumber": 29
      },
      {
        "title": "example",
        "description": "// dictionary data\nchords.data['M7'] // => { name: 'Maj7', aliases: ['M7'],\n                  //      intervals: ['1', '3', '5', '7'], steps: [ ...],\n                  //      binary: '10010010001', decimal: 2193 }\n\n// get chord by binary numbers\nchords.data['100010010001'] === chords.data['Maj7']\nchords.data[2193] === chords.data['Maj7']",
        "lineNumber": 36
      },
      {
        "title": "example",
        "description": "// available names\nchords.names // => ['Maj7', 'm7']\nchords.aliases // => ['Maj7', 'm7', 'M7']",
        "lineNumber": 46
      },
      {
        "title": "kind",
        "kind": "function"
      },
      {
        "title": "memberof",
        "description": "module"
      },
      {
        "title": "static"
      }
    ],
    "loc": {
      "start": {
        "line": 7,
        "column": 0
      },
      "end": {
        "line": 56,
        "column": 3
      }
    },
    "context": {
      "loc": {
        "start": {
          "line": 57,
          "column": 0
        },
        "end": {
          "line": 72,
          "column": 0
        }
      },
      "file": "./packages/music-dictionary/index.js",
      "code": "'use strict'\n\nvar parse = require('music-notation/interval/parse')\nvar R = require('music-notation/note/regex')\nvar transpose = require('note-transposer')\n\n/**\n * Create a musical dictionary. A musical dictionary is a function that given\n * a name (and optionally a tonic) returns an array of notes.\n *\n * A dictionary is created from a HashMap. It maps a name to a string with\n * an interval list and, optionally, an alternative name list (see example)\n *\n * Additionally, the dictionary has properties (see examples):\n *\n * - data: a hash with the dictionary data\n * - names: an array with all the names\n * - aliases: an array with all the names including aliases\n * - source: the source of the dictionary\n *\n * Each value of the data hash have the following properties:\n *\n * - name: the name\n * - aliases: an array with the alternative names\n * - intervals: an array with the intervals\n * - steps: an array with the intervals in __array notation__\n * - binary: a binary representation of the set\n * - decimal: the decimal representation of the set\n *\n * @name dictionary\n * @function\n * @param {Hash} source - the dictionary source\n * @return {Function} the dictionary\n *\n * @example\n * var dictionary = require('music-dictionary')\n * var chords = dictionary({'Maj7': ['1 3 5 7', ['M7']], 'm7': ['1 3b 5 7b'] })\n * chords('CMaj7') // => ['C', 'E', 'G', 'B']\n * chords('DM7') // => ['D', 'F#', 'A', 'C#']\n * chords('Bm7') // => ['B', 'D', 'F#', 'A']\n *\n * @example\n * // dictionary data\n * chords.data['M7'] // => { name: 'Maj7', aliases: ['M7'],\n *                   //      intervals: ['1', '3', '5', '7'], steps: [ ...],\n *                   //      binary: '10010010001', decimal: 2193 }\n *\n * // get chord by binary numbers\n * chords.data['100010010001'] === chords.data['Maj7']\n * chords.data[2193] === chords.data['Maj7']\n *\n * @example\n * // available names\n * chords.names // => ['Maj7', 'm7']\n * chords.aliases // => ['Maj7', 'm7', 'M7']\n */\nmodule.exports = function (src) {\n  function dict (name, tonic) {\n    var data = dict.props(name)\n    if (!data) {\n      var n = R.exec(name)\n      data = n ? dict.props(n[5]) : null\n      if (!data) return []\n      tonic = tonic === false ? tonic : tonic || n[1] + n[2] + n[3]\n    }\n    if (typeof tonic === 'undefined') return function (t) { return dict(name, t) }\n    return data.intervals.map(transpose(tonic))\n  }\n  return build(src, dict)\n}\n\nfunction build (src, dict) {\n  var data = {}\n  var names = Object.keys(src)\n  var aliases = names.slice()\n\n  dict.props = function (name) { return data[name] }\n  dict.names = function (a) { return (a ? aliases : names).slice() }\n\n  names.forEach(function (k) {\n    var d = src[k]\n    var c = { name: k, aliases: d[1] || [] }\n    c.intervals = d[0].split(' ')\n    c.steps = c.intervals.map(parse)\n    c.binary = binary([0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], c.steps)\n    c.decimal = parseInt(c.binary, 2)\n    data[k] = data[c.binary] = data[c.decimal] = c\n    c.aliases.forEach(function (a) { data[a] = c })\n    if (c.aliases.length > 0) aliases = aliases.concat(c.aliases)\n  })\n  return dict\n}\n\nfunction binary (num, intervals) {\n  intervals.forEach(function (i) { num[(i[0] * 7 + i[1] * 12) % 12] = '1' })\n  return num.join('')\n}"
    },
    "name": "dictionary",
    "params": [
      {
        "title": "param",
        "description": "the dictionary source",
        "lineNumber": 26,
        "type": {
          "type": "NameExpression",
          "name": "Hash"
        },
        "name": "source"
      }
    ],
    "returns": [
      {
        "title": "returns",
        "description": "the dictionary",
        "lineNumber": 27,
        "type": {
          "type": "NameExpression",
          "name": "Function"
        }
      }
    ],
    "examples": [
      "<span class=\"hljs-keyword\">var</span> dictionary = <span class=\"hljs-built_in\">require</span>(<span class=\"hljs-string\">'music-dictionary'</span>)\n<span class=\"hljs-keyword\">var</span> chords = dictionary({<span class=\"hljs-string\">'Maj7'</span>: [<span class=\"hljs-string\">'1 3 5 7'</span>, [<span class=\"hljs-string\">'M7'</span>]], <span class=\"hljs-string\">'m7'</span>: [<span class=\"hljs-string\">'1 3b 5 7b'</span>] })\nchords(<span class=\"hljs-string\">'CMaj7'</span>) <span class=\"hljs-comment\">// =&gt; ['C', 'E', 'G', 'B']</span>\nchords(<span class=\"hljs-string\">'DM7'</span>) <span class=\"hljs-comment\">// =&gt; ['D', 'F#', 'A', 'C#']</span>\nchords(<span class=\"hljs-string\">'Bm7'</span>) <span class=\"hljs-comment\">// =&gt; ['B', 'D', 'F#', 'A']</span>",
      "<span class=\"hljs-comment\">// dictionary data</span>\nchords.data[<span class=\"hljs-string\">'M7'</span>] <span class=\"hljs-comment\">// =&gt; { name: 'Maj7', aliases: ['M7'],</span>\n                  <span class=\"hljs-comment\">//      intervals: ['1', '3', '5', '7'], steps: [ ...],</span>\n                  <span class=\"hljs-comment\">//      binary: '10010010001', decimal: 2193 }</span>\n\n<span class=\"hljs-comment\">// get chord by binary numbers</span>\nchords.data[<span class=\"hljs-string\">'100010010001'</span>] === chords.data[<span class=\"hljs-string\">'Maj7'</span>]\nchords.data[<span class=\"hljs-number\">2193</span>] === chords.data[<span class=\"hljs-string\">'Maj7'</span>]",
      "<span class=\"hljs-comment\">// available names</span>\nchords.names <span class=\"hljs-comment\">// =&gt; ['Maj7', 'm7']</span>\nchords.aliases <span class=\"hljs-comment\">// =&gt; ['Maj7', 'm7', 'M7']</span>"
    ],
    "kind": "function",
    "memberof": "module",
    "scope": "static",
    "members": {
      "instance": [],
      "static": []
    },
    "events": [],
    "path": [
      "dictionary"
    ]
  },
  {
    "description": "Try to get a simpler enharmonic note name",
    "tags": [
      {
        "title": "name",
        "description": null,
        "lineNumber": 3,
        "name": "enharmonics.simplify"
      },
      {
        "title": "function",
        "description": null,
        "lineNumber": 4,
        "name": null
      },
      {
        "title": "param",
        "description": "the note to simplify",
        "lineNumber": 6,
        "type": {
          "type": "NameExpression",
          "name": "String"
        },
        "name": "note"
      },
      {
        "title": "returns",
        "description": "the simplfiied note (can be the same)",
        "lineNumber": 7,
        "type": {
          "type": "NameExpression",
          "name": "String"
        }
      },
      {
        "title": "example",
        "description": "var enharmonics = require('enharmonics')\nenharmonics.simplify('B#3') // => 'C4'",
        "lineNumber": 9
      },
      {
        "title": "kind",
        "kind": "function"
      },
      {
        "title": "memberof",
        "description": "enharmonics"
      },
      {
        "title": "static"
      }
    ],
    "loc": {
      "start": {
        "line": 32,
        "column": 0
      },
      "end": {
        "line": 43,
        "column": 3
      }
    },
    "context": {
      "loc": {
        "start": {
          "line": 44,
          "column": 0
        },
        "end": {
          "line": 51,
          "column": 0
        }
      },
      "file": "./packages/enharmonics/index.js",
      "code": "'use strict'\n\nvar transpose = require('note-transposer')\n\nvar ASC = [-12, 7] // dimished second\nvar DESC = [12, -7] // descending dimished second\n\n/**\n * Get the enharmonics of a note. It returns an array of three elements: the\n * below enharmonic, the note, and the upper enharmonic\n *\n * @name note.enharmonics\n * @function\n * @param {String} note - the note to get the enharmonics from\n * @return {Array} an array of pitches ordered by distance to the given one\n *\n * @example\n * enharmonics = require('enharmonics')\n * enharmonics('C') // => ['B#', 'C', 'Dbb']\n * enharmonics('A') // => ['G##', 'A', 'Bbb']\n * enharmonics('C#4') // => ['B##3', 'C#4' 'Db4']\n * enharmonics('Db') // => ['C#', 'Db', 'Ebbb'])\n */\nfunction enharmonics (pitch) {\n  var enharmonics = []\n  enharmonics.push(transpose(DESC, pitch))\n  enharmonics.push(pitch)\n  enharmonics.push(transpose(ASC, pitch))\n  return enharmonics\n}\n\n/**\n * Try to get a simpler enharmonic note name\n *\n * @name enharmonics.simplify\n * @function\n * @param {String} note - the note to simplify\n * @return {String} the simplfiied note (can be the same)\n *\n * @example\n * var enharmonics = require('enharmonics')\n * enharmonics.simplify('B#3') // => 'C4'\n */\nenharmonics.simplify = function (pitch) {\n  return enharmonics(pitch).reduce(function (simple, next) {\n    if (!simple) return next\n    return simple.length > next.length ? next : simple\n  }, null)\n}\n\nmodule.exports = enharmonics\n"
    },
    "name": "enharmonics.simplify",
    "params": [
      {
        "title": "param",
        "description": "the note to simplify",
        "lineNumber": 6,
        "type": {
          "type": "NameExpression",
          "name": "String"
        },
        "name": "note"
      }
    ],
    "returns": [
      {
        "title": "returns",
        "description": "the simplfiied note (can be the same)",
        "lineNumber": 7,
        "type": {
          "type": "NameExpression",
          "name": "String"
        }
      }
    ],
    "examples": [
      "<span class=\"hljs-keyword\">var</span> enharmonics = <span class=\"hljs-built_in\">require</span>(<span class=\"hljs-string\">'enharmonics'</span>)\nenharmonics.simplify(<span class=\"hljs-string\">'B#3'</span>) <span class=\"hljs-comment\">// =&gt; 'C4'</span>"
    ],
    "kind": "function",
    "memberof": "enharmonics",
    "scope": "static",
    "members": {
      "instance": [],
      "static": []
    },
    "events": [],
    "path": [
      "enharmonics.simplify"
    ]
  },
  {
    "description": "Filter notes",
    "tags": [
      {
        "title": "param",
        "description": "the note filter",
        "lineNumber": 3,
        "type": {
          "type": "UnionType",
          "elements": [
            {
              "type": "NameExpression",
              "name": "Function"
            },
            {
              "type": "NameExpression",
              "name": "String"
            },
            {
              "type": "NameExpression",
              "name": "Array"
            }
          ]
        },
        "name": "filter"
      },
      {
        "title": "param",
        "description": "the notes to be filtered",
        "lineNumber": 4,
        "type": {
          "type": "NameExpression",
          "name": "Array"
        },
        "name": "notes"
      },
      {
        "title": "returns",
        "description": "the notes filtered",
        "lineNumber": 5,
        "type": {
          "type": "NameExpression",
          "name": "Array"
        }
      },
      {
        "title": "example",
        "description": null,
        "lineNumber": 7
      },
      {
        "title": "name",
        "name": "exports"
      },
      {
        "title": "kind",
        "kind": "function"
      },
      {
        "title": "memberof",
        "description": "module"
      },
      {
        "title": "static"
      }
    ],
    "loc": {
      "start": {
        "line": 6,
        "column": 0
      },
      "end": {
        "line": 14,
        "column": 3
      }
    },
    "context": {
      "loc": {
        "start": {
          "line": 15,
          "column": 0
        },
        "end": {
          "line": 33,
          "column": 0
        }
      },
      "file": "./packages/note-filter/index.js",
      "code": "'use strict'\n\nvar gamut = require('music-gamut')\nvar enharmonics = require('enharmonics')\n\n/**\n * Filter notes\n *\n * @param {Function|String|Array} filter - the note filter\n * @param {Array} notes - the notes to be filtered\n * @return {Array} the notes filtered\n *\n * @example\n */\nmodule.exports = function (filter, notes) {\n  filter = gamut.parse(filter)\n  return gamut.operation(function (notes) {\n    // hand made filter (to allow enharmonic change)\n    var r = []\n    for (var i = 0; i < notes.length; i++) {\n      var inc = included(filter, notes[i])\n      if (inc) r.push(inc)\n    }\n    return r\n  })(notes)\n}\n\n/**\n * Check if the given note (or any of its enharmonics) is included in the\n * filter array\n * @private\n */\nfunction included (filter, note) {\n  var notes = enharmonics(note)\n  for (var i = 0; i < filter.length; i++) {\n    for (var e = 0; e < notes.length; e++) {\n      if (filter[i][0] === notes[e][0]) return notes[e]\n    }\n  }\n  return null\n}"
    },
    "params": [
      {
        "title": "param",
        "description": "the note filter",
        "lineNumber": 3,
        "type": {
          "type": "UnionType",
          "elements": [
            {
              "type": "NameExpression",
              "name": "Function"
            },
            {
              "type": "NameExpression",
              "name": "String"
            },
            {
              "type": "NameExpression",
              "name": "Array"
            }
          ]
        },
        "name": "filter"
      },
      {
        "title": "param",
        "description": "the notes to be filtered",
        "lineNumber": 4,
        "type": {
          "type": "NameExpression",
          "name": "Array"
        },
        "name": "notes"
      }
    ],
    "returns": [
      {
        "title": "returns",
        "description": "the notes filtered",
        "lineNumber": 5,
        "type": {
          "type": "NameExpression",
          "name": "Array"
        }
      }
    ],
    "examples": [
      ""
    ],
    "name": "exports",
    "kind": "function",
    "memberof": "module",
    "scope": "static",
    "members": {
      "instance": [],
      "static": []
    },
    "events": [],
    "path": [
      "exports"
    ]
  },
  {
    "description": "Get the inversion of an interval",
    "tags": [
      {
        "title": "param",
        "description": "the interval to invert in interval shorthand\nnotation or interval array notation",
        "lineNumber": 3,
        "type": {
          "type": "UnionType",
          "elements": [
            {
              "type": "NameExpression",
              "name": "String"
            },
            {
              "type": "NameExpression",
              "name": "Array"
            }
          ]
        },
        "name": "interval"
      },
      {
        "title": "returns",
        "description": "the inverted interval",
        "lineNumber": 5,
        "type": {
          "type": "UnionType",
          "elements": [
            {
              "type": "NameExpression",
              "name": "String"
            },
            {
              "type": "NameExpression",
              "name": "Array"
            }
          ]
        }
      },
      {
        "title": "example",
        "description": null,
        "lineNumber": 7
      },
      {
        "title": "name",
        "name": "exports"
      },
      {
        "title": "kind",
        "kind": "function"
      },
      {
        "title": "memberof",
        "description": "module"
      },
      {
        "title": "static"
      }
    ],
    "loc": {
      "start": {
        "line": 7,
        "column": 0
      },
      "end": {
        "line": 15,
        "column": 3
      }
    },
    "context": {
      "loc": {
        "start": {
          "line": 16,
          "column": 0
        },
        "end": {
          "line": 18,
          "column": 0
        }
      },
      "file": "./packages/invert-interval/index.js",
      "code": "'use strict'\n\nvar parse = require('music-notation/interval/parse')\nvar str = require('music-notation/interval/str')\nvar op = require('music-notation/operation')\n\n/**\n * Get the inversion of an interval\n *\n * @param {String|Array} interval - the interval to invert in interval shorthand\n * notation or interval array notation\n * @return {String|Array} the inverted interval\n *\n * @example\n */\nmodule.exports = op(parse, str, function (i) {\n})\n"
    },
    "params": [
      {
        "title": "param",
        "description": "the interval to invert in interval shorthand\nnotation or interval array notation",
        "lineNumber": 3,
        "type": {
          "type": "UnionType",
          "elements": [
            {
              "type": "NameExpression",
              "name": "String"
            },
            {
              "type": "NameExpression",
              "name": "Array"
            }
          ]
        },
        "name": "interval"
      }
    ],
    "returns": [
      {
        "title": "returns",
        "description": "the inverted interval",
        "lineNumber": 5,
        "type": {
          "type": "UnionType",
          "elements": [
            {
              "type": "NameExpression",
              "name": "String"
            },
            {
              "type": "NameExpression",
              "name": "Array"
            }
          ]
        }
      }
    ],
    "examples": [
      ""
    ],
    "name": "exports",
    "kind": "function",
    "memberof": "module",
    "scope": "static",
    "members": {
      "instance": [],
      "static": []
    },
    "events": [],
    "path": [
      "exports"
    ]
  },
  {
    "description": "",
    "tags": [
      {
        "title": "name",
        "name": "gamut"
      }
    ],
    "loc": {
      "start": {
        "line": 3,
        "column": 0
      },
      "end": {
        "line": 5,
        "column": 3
      }
    },
    "context": {
      "loc": {
        "start": {
          "line": 7,
          "column": 0
        },
        "end": {
          "line": 10,
          "column": 0
        }
      },
      "file": "./packages/pitch-sort/index.js",
      "code": "'use strict'\n\n/**\n * @module music-gamut\n */\n\nvar gamut = require('music-gamut')\n\n\nmodule.exports = \n/**\n * Sort a collection of notes or intervals. It can sort in ascending or descending\n * pitch order or using a custom comparator.\n *\n * This function is currified\n *\n * @name sort\n * @function\n * @param {Function|Boolean} comparator - the comparator function, or true to\n * sort in ascending pitch order or false to sort in descending pitch order\n * @param {String|Array} source - the notes or intervals list\n * @return {Array} the notes or intervals sorted\n *\n * @example\n * var sort = require('note-sorter')\n * sort(true, 'c5 d2 f4 D2') // => ['D2', 'D2', 'F4', 'C5']\n * sort(false, 'c5 d2 f4 D2') // => ['C5', 'F4', 'D2', 'D2']\n *\n * // partially applied\n * var descending = sort(false)\n * descending('C D E F G') // => [ 'G', 'F', 'E', 'D', 'C' ]\n */\nfunction sort (comp, source) {\n  if (arguments.length > 1) return sort(comp)(source)\n  if (comp === null || comp === true) comp = asc\n  else if (comp === false) comp = desc\n  return gamut.operation(function (g) { return g.sort(comp) })\n}\n\nfunction asc (a, b) { return height(a) - height(b) }\nfunction desc (a, b) { return -asc(a, b) }\n\n// Uses a custom height function (instead of semitones) because 1) the Infinty,\n// for null values and 2) the pitch class octave number\nfunction height (p) {\n  if (!p) return -Infinity\n  var f = p[0] * 7\n  var o = p[1] || p[1] === 0 ? p[1] : -Math.floor(f / 12) - 10\n  return f + o * 12\n}"
    },
    "name": "gamut",
    "members": {
      "instance": [],
      "static": [
        {
          "description": "Decorate a function to work with gamuts.\n\nThe function to decorate receives an array of pitches in\n[array notation]()  and should return the desired transformed array.",
          "tags": [
            {
              "title": "name",
              "description": null,
              "lineNumber": 6,
              "name": "gamut.operation"
            },
            {
              "title": "function",
              "description": null,
              "lineNumber": 7,
              "name": null
            },
            {
              "title": "param",
              "description": "the function to decorate",
              "lineNumber": 9,
              "type": {
                "type": "NameExpression",
                "name": "Function"
              },
              "name": "fn"
            },
            {
              "title": "returns",
              "description": "the decorated function",
              "lineNumber": 10,
              "type": {
                "type": "NameExpression",
                "name": "Function"
              }
            },
            {
              "title": "kind",
              "kind": "function"
            },
            {
              "title": "memberof",
              "description": "gamut"
            },
            {
              "title": "static"
            }
          ],
          "loc": {
            "start": {
              "line": 49,
              "column": 0
            },
            "end": {
              "line": 59,
              "column": 3
            }
          },
          "context": {
            "loc": {
              "start": {
                "line": 60,
                "column": 0
              },
              "end": {
                "line": 89,
                "column": 0
              }
            },
            "file": "./packages/music-gamut/index.js",
            "code": "'use strict'\n\nvar parse = require('music-notation/pitch/parse')\nvar str = require('music-notation/pitch/str')\nvar SEP = /\\s*\\|\\s*|\\s*,\\s*|\\s+/\n\nvar isArray = Array.isArray\nfunction toStr (s) { return isArray(s) ? str(s) : s }\nfunction toArr (s) { return isArray(s) ? s : parse(s) }\n\nfunction id (e) { return e }\n\n/**\n * A gamut is a collection of intervals, pitch classes or notes.\n * Scales, chords, pitch sets are examples of gamuts.\n *\n * With this function you can manipulate music gamuts in array notation.\n *\n * @name gamut\n * @param {String|Function} operation - the operation to perfom\n * @param {String|Array} source - a list of elements\n * @return {Array} a list of pitches\n *\n * @example\n * var gamut = require('music-gamut')\n * gamut('c2 bb fx blah') // => ['C2', 'Bb', 'F##', null]\n */\nfunction gamut (op, source) {\n  if (arguments.length === 1 && typeof op !== 'function') return gamut(id, op)\n  return gamut.operation(op)(source)\n}\n\n/**\n * Given a gamut get its notes or intervals in [array notation]()\n *\n * @name gamut.parse\n * @function\n * @param {Array|String} source - the notes or intervals\n * @return {Array} the notes or intervals in array notation\n *\n * @example\n * var gamut = require('music-gamut')\n * gamut.parse('C D E') // => [ [0], [2], [4] ]\n */\ngamut.parse = function (source) {\n  return gamut.split(source).map(toArr)\n}\n\n/**\n * Decorate a function to work with gamuts.\n *\n * The function to decorate receives an array of pitches in\n * [array notation]()  and should return the desired transformed array.\n *\n * @name gamut.operation\n * @function\n * @param {Function} fn - the function to decorate\n * @return {Function} the decorated function\n */\ngamut.operation = function (fn) {\n  return function (source) {\n    var g = gamut.split(source)\n    if (isArray(g[0])) return fn(g)\n    var v = fn(g.map(parse))\n    return isArray(v) ? v.map(toStr) : v\n  }\n}\n\n/**\n * Convert a source to an array. If the source is an array, return it.\n *\n * Aside from an array itself, the source can be a\n * string with elements separated by spaces, commas or bars (`|`) or a single\n * element that will be wrapped inside an array\n *\n * This function __does not perform any transformation__ of the array elements.\n * and __it always return an array, even if its empty__.\n *\n * @name gamut.split\n * @function\n * @param {String|Array} source - the source\n * @return {Array} the source as array\n *\n * @example\n * var G = require('music-gamut')\n * G.split('a | B C , Dmaj7') // => ['a', 'B', 'C', 'Dmaj7']\n * G.split() // => []\n */\ngamut.split = function (source) {\n  if (isArray(source)) return source\n  else if (typeof source === 'string') return source.trim().split(SEP)\n  else if (source === null || typeof source === 'undefined') return []\n  else return [ source ]\n}\n\n/**\n * Rotate the gamut\n *\n * @name gamut.rotate\n * @function\n * @param {Integer} count - the number of rotations\n * @param {String|Array} gamut - a list of notes or intervals\n * @return {Array} the gamut rotated count times\n *\n * @example\n * var G = require('music-gamut')\n * G.rotate(1, 'C D E') // => ['D', 'E', 'C']\n */\ngamut.rotate = function (count, source) {\n  var g = gamut.split(source)\n  var len = g.length\n  var n = ((count % len) + len) % len\n  return g.slice(n, len).concat(g.slice(0, n))\n}\n\n/**\n * Select some elements from a gamut\n *\n * @name gamut.select\n * @function\n * @param {String|Array} numbers - a __1-based__ index of the elements\n * @param {String|Array} gamut - the notes or intervals\n * @return {Array} the selected elements\n *\n * @example\n * var gamut = require('music-gamut')\n * gamut.select('1 3 5', 'C D E F G A B') // => ['C', 'E', 'G']\n */\ngamut.select = function s (nums, src) {\n  if (arguments.length === 1) return function (g) { return s(nums, g) }\n  var g = gamut.split(src)\n  return gamut.split(nums).map(function (n) {\n    return g[n - 1]\n  })\n}\n\nif (typeof module === 'object' && module.exports) module.exports = gamut\nif (typeof window !== 'undefined') window.gamut = gamut\n"
          },
          "name": "gamut.operation",
          "params": [
            {
              "title": "param",
              "description": "the function to decorate",
              "lineNumber": 9,
              "type": {
                "type": "NameExpression",
                "name": "Function"
              },
              "name": "fn"
            }
          ],
          "returns": [
            {
              "title": "returns",
              "description": "the decorated function",
              "lineNumber": 10,
              "type": {
                "type": "NameExpression",
                "name": "Function"
              }
            }
          ],
          "kind": "function",
          "memberof": "gamut",
          "scope": "static",
          "members": {
            "instance": [],
            "static": []
          },
          "events": [],
          "path": [
            "gamut",
            "gamut.operation"
          ]
        },
        {
          "description": "Given a gamut get its notes or intervals in [array notation]()",
          "tags": [
            {
              "title": "name",
              "description": null,
              "lineNumber": 3,
              "name": "gamut.parse"
            },
            {
              "title": "function",
              "description": null,
              "lineNumber": 4,
              "name": null
            },
            {
              "title": "param",
              "description": "the notes or intervals",
              "lineNumber": 6,
              "type": {
                "type": "UnionType",
                "elements": [
                  {
                    "type": "NameExpression",
                    "name": "Array"
                  },
                  {
                    "type": "NameExpression",
                    "name": "String"
                  }
                ]
              },
              "name": "source"
            },
            {
              "title": "returns",
              "description": "the notes or intervals in array notation",
              "lineNumber": 7,
              "type": {
                "type": "NameExpression",
                "name": "Array"
              }
            },
            {
              "title": "example",
              "description": "var gamut = require('music-gamut')\ngamut.parse('C D E') // => [ [0], [2], [4] ]",
              "lineNumber": 9
            },
            {
              "title": "kind",
              "kind": "function"
            },
            {
              "title": "memberof",
              "description": "gamut"
            },
            {
              "title": "static"
            }
          ],
          "loc": {
            "start": {
              "line": 33,
              "column": 0
            },
            "end": {
              "line": 44,
              "column": 3
            }
          },
          "context": {
            "loc": {
              "start": {
                "line": 45,
                "column": 0
              },
              "end": {
                "line": 60,
                "column": 0
              }
            },
            "file": "./packages/music-gamut/index.js",
            "code": "'use strict'\n\nvar parse = require('music-notation/pitch/parse')\nvar str = require('music-notation/pitch/str')\nvar SEP = /\\s*\\|\\s*|\\s*,\\s*|\\s+/\n\nvar isArray = Array.isArray\nfunction toStr (s) { return isArray(s) ? str(s) : s }\nfunction toArr (s) { return isArray(s) ? s : parse(s) }\n\nfunction id (e) { return e }\n\n/**\n * A gamut is a collection of intervals, pitch classes or notes.\n * Scales, chords, pitch sets are examples of gamuts.\n *\n * With this function you can manipulate music gamuts in array notation.\n *\n * @name gamut\n * @param {String|Function} operation - the operation to perfom\n * @param {String|Array} source - a list of elements\n * @return {Array} a list of pitches\n *\n * @example\n * var gamut = require('music-gamut')\n * gamut('c2 bb fx blah') // => ['C2', 'Bb', 'F##', null]\n */\nfunction gamut (op, source) {\n  if (arguments.length === 1 && typeof op !== 'function') return gamut(id, op)\n  return gamut.operation(op)(source)\n}\n\n/**\n * Given a gamut get its notes or intervals in [array notation]()\n *\n * @name gamut.parse\n * @function\n * @param {Array|String} source - the notes or intervals\n * @return {Array} the notes or intervals in array notation\n *\n * @example\n * var gamut = require('music-gamut')\n * gamut.parse('C D E') // => [ [0], [2], [4] ]\n */\ngamut.parse = function (source) {\n  return gamut.split(source).map(toArr)\n}\n\n/**\n * Decorate a function to work with gamuts.\n *\n * The function to decorate receives an array of pitches in\n * [array notation]()  and should return the desired transformed array.\n *\n * @name gamut.operation\n * @function\n * @param {Function} fn - the function to decorate\n * @return {Function} the decorated function\n */\ngamut.operation = function (fn) {\n  return function (source) {\n    var g = gamut.split(source)\n    if (isArray(g[0])) return fn(g)\n    var v = fn(g.map(parse))\n    return isArray(v) ? v.map(toStr) : v\n  }\n}\n\n/**\n * Convert a source to an array. If the source is an array, return it.\n *\n * Aside from an array itself, the source can be a\n * string with elements separated by spaces, commas or bars (`|`) or a single\n * element that will be wrapped inside an array\n *\n * This function __does not perform any transformation__ of the array elements.\n * and __it always return an array, even if its empty__.\n *\n * @name gamut.split\n * @function\n * @param {String|Array} source - the source\n * @return {Array} the source as array\n *\n * @example\n * var G = require('music-gamut')\n * G.split('a | B C , Dmaj7') // => ['a', 'B', 'C', 'Dmaj7']\n * G.split() // => []\n */\ngamut.split = function (source) {\n  if (isArray(source)) return source\n  else if (typeof source === 'string') return source.trim().split(SEP)\n  else if (source === null || typeof source === 'undefined') return []\n  else return [ source ]\n}\n\n/**\n * Rotate the gamut\n *\n * @name gamut.rotate\n * @function\n * @param {Integer} count - the number of rotations\n * @param {String|Array} gamut - a list of notes or intervals\n * @return {Array} the gamut rotated count times\n *\n * @example\n * var G = require('music-gamut')\n * G.rotate(1, 'C D E') // => ['D', 'E', 'C']\n */\ngamut.rotate = function (count, source) {\n  var g = gamut.split(source)\n  var len = g.length\n  var n = ((count % len) + len) % len\n  return g.slice(n, len).concat(g.slice(0, n))\n}\n\n/**\n * Select some elements from a gamut\n *\n * @name gamut.select\n * @function\n * @param {String|Array} numbers - a __1-based__ index of the elements\n * @param {String|Array} gamut - the notes or intervals\n * @return {Array} the selected elements\n *\n * @example\n * var gamut = require('music-gamut')\n * gamut.select('1 3 5', 'C D E F G A B') // => ['C', 'E', 'G']\n */\ngamut.select = function s (nums, src) {\n  if (arguments.length === 1) return function (g) { return s(nums, g) }\n  var g = gamut.split(src)\n  return gamut.split(nums).map(function (n) {\n    return g[n - 1]\n  })\n}\n\nif (typeof module === 'object' && module.exports) module.exports = gamut\nif (typeof window !== 'undefined') window.gamut = gamut\n"
          },
          "name": "gamut.parse",
          "params": [
            {
              "title": "param",
              "description": "the notes or intervals",
              "lineNumber": 6,
              "type": {
                "type": "UnionType",
                "elements": [
                  {
                    "type": "NameExpression",
                    "name": "Array"
                  },
                  {
                    "type": "NameExpression",
                    "name": "String"
                  }
                ]
              },
              "name": "source"
            }
          ],
          "returns": [
            {
              "title": "returns",
              "description": "the notes or intervals in array notation",
              "lineNumber": 7,
              "type": {
                "type": "NameExpression",
                "name": "Array"
              }
            }
          ],
          "examples": [
            "<span class=\"hljs-keyword\">var</span> gamut = <span class=\"hljs-built_in\">require</span>(<span class=\"hljs-string\">'music-gamut'</span>)\ngamut.parse(<span class=\"hljs-string\">'C D E'</span>) <span class=\"hljs-comment\">// =&gt; [ [0], [2], [4] ]</span>"
          ],
          "kind": "function",
          "memberof": "gamut",
          "scope": "static",
          "members": {
            "instance": [],
            "static": []
          },
          "events": [],
          "path": [
            "gamut",
            "gamut.parse"
          ]
        },
        {
          "description": "Rotate the gamut",
          "tags": [
            {
              "title": "name",
              "description": null,
              "lineNumber": 3,
              "name": "gamut.rotate"
            },
            {
              "title": "function",
              "description": null,
              "lineNumber": 4,
              "name": null
            },
            {
              "title": "param",
              "description": "the number of rotations",
              "lineNumber": 6,
              "type": {
                "type": "NameExpression",
                "name": "Integer"
              },
              "name": "count"
            },
            {
              "title": "param",
              "description": "a list of notes or intervals",
              "lineNumber": 7,
              "type": {
                "type": "UnionType",
                "elements": [
                  {
                    "type": "NameExpression",
                    "name": "String"
                  },
                  {
                    "type": "NameExpression",
                    "name": "Array"
                  }
                ]
              },
              "name": "gamut"
            },
            {
              "title": "returns",
              "description": "the gamut rotated count times",
              "lineNumber": 8,
              "type": {
                "type": "NameExpression",
                "name": "Array"
              }
            },
            {
              "title": "example",
              "description": "var G = require('music-gamut')\nG.rotate(1, 'C D E') // => ['D', 'E', 'C']",
              "lineNumber": 10
            },
            {
              "title": "kind",
              "kind": "function"
            },
            {
              "title": "memberof",
              "description": "gamut"
            },
            {
              "title": "static"
            }
          ],
          "loc": {
            "start": {
              "line": 96,
              "column": 0
            },
            "end": {
              "line": 108,
              "column": 3
            }
          },
          "context": {
            "loc": {
              "start": {
                "line": 109,
                "column": 0
              },
              "end": {
                "line": 129,
                "column": 0
              }
            },
            "file": "./packages/music-gamut/index.js",
            "code": "'use strict'\n\nvar parse = require('music-notation/pitch/parse')\nvar str = require('music-notation/pitch/str')\nvar SEP = /\\s*\\|\\s*|\\s*,\\s*|\\s+/\n\nvar isArray = Array.isArray\nfunction toStr (s) { return isArray(s) ? str(s) : s }\nfunction toArr (s) { return isArray(s) ? s : parse(s) }\n\nfunction id (e) { return e }\n\n/**\n * A gamut is a collection of intervals, pitch classes or notes.\n * Scales, chords, pitch sets are examples of gamuts.\n *\n * With this function you can manipulate music gamuts in array notation.\n *\n * @name gamut\n * @param {String|Function} operation - the operation to perfom\n * @param {String|Array} source - a list of elements\n * @return {Array} a list of pitches\n *\n * @example\n * var gamut = require('music-gamut')\n * gamut('c2 bb fx blah') // => ['C2', 'Bb', 'F##', null]\n */\nfunction gamut (op, source) {\n  if (arguments.length === 1 && typeof op !== 'function') return gamut(id, op)\n  return gamut.operation(op)(source)\n}\n\n/**\n * Given a gamut get its notes or intervals in [array notation]()\n *\n * @name gamut.parse\n * @function\n * @param {Array|String} source - the notes or intervals\n * @return {Array} the notes or intervals in array notation\n *\n * @example\n * var gamut = require('music-gamut')\n * gamut.parse('C D E') // => [ [0], [2], [4] ]\n */\ngamut.parse = function (source) {\n  return gamut.split(source).map(toArr)\n}\n\n/**\n * Decorate a function to work with gamuts.\n *\n * The function to decorate receives an array of pitches in\n * [array notation]()  and should return the desired transformed array.\n *\n * @name gamut.operation\n * @function\n * @param {Function} fn - the function to decorate\n * @return {Function} the decorated function\n */\ngamut.operation = function (fn) {\n  return function (source) {\n    var g = gamut.split(source)\n    if (isArray(g[0])) return fn(g)\n    var v = fn(g.map(parse))\n    return isArray(v) ? v.map(toStr) : v\n  }\n}\n\n/**\n * Convert a source to an array. If the source is an array, return it.\n *\n * Aside from an array itself, the source can be a\n * string with elements separated by spaces, commas or bars (`|`) or a single\n * element that will be wrapped inside an array\n *\n * This function __does not perform any transformation__ of the array elements.\n * and __it always return an array, even if its empty__.\n *\n * @name gamut.split\n * @function\n * @param {String|Array} source - the source\n * @return {Array} the source as array\n *\n * @example\n * var G = require('music-gamut')\n * G.split('a | B C , Dmaj7') // => ['a', 'B', 'C', 'Dmaj7']\n * G.split() // => []\n */\ngamut.split = function (source) {\n  if (isArray(source)) return source\n  else if (typeof source === 'string') return source.trim().split(SEP)\n  else if (source === null || typeof source === 'undefined') return []\n  else return [ source ]\n}\n\n/**\n * Rotate the gamut\n *\n * @name gamut.rotate\n * @function\n * @param {Integer} count - the number of rotations\n * @param {String|Array} gamut - a list of notes or intervals\n * @return {Array} the gamut rotated count times\n *\n * @example\n * var G = require('music-gamut')\n * G.rotate(1, 'C D E') // => ['D', 'E', 'C']\n */\ngamut.rotate = function (count, source) {\n  var g = gamut.split(source)\n  var len = g.length\n  var n = ((count % len) + len) % len\n  return g.slice(n, len).concat(g.slice(0, n))\n}\n\n/**\n * Select some elements from a gamut\n *\n * @name gamut.select\n * @function\n * @param {String|Array} numbers - a __1-based__ index of the elements\n * @param {String|Array} gamut - the notes or intervals\n * @return {Array} the selected elements\n *\n * @example\n * var gamut = require('music-gamut')\n * gamut.select('1 3 5', 'C D E F G A B') // => ['C', 'E', 'G']\n */\ngamut.select = function s (nums, src) {\n  if (arguments.length === 1) return function (g) { return s(nums, g) }\n  var g = gamut.split(src)\n  return gamut.split(nums).map(function (n) {\n    return g[n - 1]\n  })\n}\n\nif (typeof module === 'object' && module.exports) module.exports = gamut\nif (typeof window !== 'undefined') window.gamut = gamut\n"
          },
          "name": "gamut.rotate",
          "params": [
            {
              "title": "param",
              "description": "the number of rotations",
              "lineNumber": 6,
              "type": {
                "type": "NameExpression",
                "name": "Integer"
              },
              "name": "count"
            },
            {
              "title": "param",
              "description": "a list of notes or intervals",
              "lineNumber": 7,
              "type": {
                "type": "UnionType",
                "elements": [
                  {
                    "type": "NameExpression",
                    "name": "String"
                  },
                  {
                    "type": "NameExpression",
                    "name": "Array"
                  }
                ]
              },
              "name": "gamut"
            }
          ],
          "returns": [
            {
              "title": "returns",
              "description": "the gamut rotated count times",
              "lineNumber": 8,
              "type": {
                "type": "NameExpression",
                "name": "Array"
              }
            }
          ],
          "examples": [
            "<span class=\"hljs-keyword\">var</span> G = <span class=\"hljs-built_in\">require</span>(<span class=\"hljs-string\">'music-gamut'</span>)\nG.rotate(<span class=\"hljs-number\">1</span>, <span class=\"hljs-string\">'C D E'</span>) <span class=\"hljs-comment\">// =&gt; ['D', 'E', 'C']</span>"
          ],
          "kind": "function",
          "memberof": "gamut",
          "scope": "static",
          "members": {
            "instance": [],
            "static": []
          },
          "events": [],
          "path": [
            "gamut",
            "gamut.rotate"
          ]
        },
        {
          "description": "Select some elements from a gamut",
          "tags": [
            {
              "title": "name",
              "description": null,
              "lineNumber": 3,
              "name": "gamut.select"
            },
            {
              "title": "function",
              "description": null,
              "lineNumber": 4,
              "name": null
            },
            {
              "title": "param",
              "description": "a __1-based__ index of the elements",
              "lineNumber": 6,
              "type": {
                "type": "UnionType",
                "elements": [
                  {
                    "type": "NameExpression",
                    "name": "String"
                  },
                  {
                    "type": "NameExpression",
                    "name": "Array"
                  }
                ]
              },
              "name": "numbers"
            },
            {
              "title": "param",
              "description": "the notes or intervals",
              "lineNumber": 7,
              "type": {
                "type": "UnionType",
                "elements": [
                  {
                    "type": "NameExpression",
                    "name": "String"
                  },
                  {
                    "type": "NameExpression",
                    "name": "Array"
                  }
                ]
              },
              "name": "gamut"
            },
            {
              "title": "returns",
              "description": "the selected elements",
              "lineNumber": 8,
              "type": {
                "type": "NameExpression",
                "name": "Array"
              }
            },
            {
              "title": "example",
              "description": "var gamut = require('music-gamut')\ngamut.select('1 3 5', 'C D E F G A B') // => ['C', 'E', 'G']",
              "lineNumber": 10
            },
            {
              "title": "kind",
              "kind": "function"
            },
            {
              "title": "memberof",
              "description": "gamut"
            },
            {
              "title": "static"
            }
          ],
          "loc": {
            "start": {
              "line": 116,
              "column": 0
            },
            "end": {
              "line": 128,
              "column": 3
            }
          },
          "context": {
            "loc": {
              "start": {
                "line": 129,
                "column": 0
              },
              "end": {
                "line": 137,
                "column": 0
              }
            },
            "file": "./packages/music-gamut/index.js",
            "code": "'use strict'\n\nvar parse = require('music-notation/pitch/parse')\nvar str = require('music-notation/pitch/str')\nvar SEP = /\\s*\\|\\s*|\\s*,\\s*|\\s+/\n\nvar isArray = Array.isArray\nfunction toStr (s) { return isArray(s) ? str(s) : s }\nfunction toArr (s) { return isArray(s) ? s : parse(s) }\n\nfunction id (e) { return e }\n\n/**\n * A gamut is a collection of intervals, pitch classes or notes.\n * Scales, chords, pitch sets are examples of gamuts.\n *\n * With this function you can manipulate music gamuts in array notation.\n *\n * @name gamut\n * @param {String|Function} operation - the operation to perfom\n * @param {String|Array} source - a list of elements\n * @return {Array} a list of pitches\n *\n * @example\n * var gamut = require('music-gamut')\n * gamut('c2 bb fx blah') // => ['C2', 'Bb', 'F##', null]\n */\nfunction gamut (op, source) {\n  if (arguments.length === 1 && typeof op !== 'function') return gamut(id, op)\n  return gamut.operation(op)(source)\n}\n\n/**\n * Given a gamut get its notes or intervals in [array notation]()\n *\n * @name gamut.parse\n * @function\n * @param {Array|String} source - the notes or intervals\n * @return {Array} the notes or intervals in array notation\n *\n * @example\n * var gamut = require('music-gamut')\n * gamut.parse('C D E') // => [ [0], [2], [4] ]\n */\ngamut.parse = function (source) {\n  return gamut.split(source).map(toArr)\n}\n\n/**\n * Decorate a function to work with gamuts.\n *\n * The function to decorate receives an array of pitches in\n * [array notation]()  and should return the desired transformed array.\n *\n * @name gamut.operation\n * @function\n * @param {Function} fn - the function to decorate\n * @return {Function} the decorated function\n */\ngamut.operation = function (fn) {\n  return function (source) {\n    var g = gamut.split(source)\n    if (isArray(g[0])) return fn(g)\n    var v = fn(g.map(parse))\n    return isArray(v) ? v.map(toStr) : v\n  }\n}\n\n/**\n * Convert a source to an array. If the source is an array, return it.\n *\n * Aside from an array itself, the source can be a\n * string with elements separated by spaces, commas or bars (`|`) or a single\n * element that will be wrapped inside an array\n *\n * This function __does not perform any transformation__ of the array elements.\n * and __it always return an array, even if its empty__.\n *\n * @name gamut.split\n * @function\n * @param {String|Array} source - the source\n * @return {Array} the source as array\n *\n * @example\n * var G = require('music-gamut')\n * G.split('a | B C , Dmaj7') // => ['a', 'B', 'C', 'Dmaj7']\n * G.split() // => []\n */\ngamut.split = function (source) {\n  if (isArray(source)) return source\n  else if (typeof source === 'string') return source.trim().split(SEP)\n  else if (source === null || typeof source === 'undefined') return []\n  else return [ source ]\n}\n\n/**\n * Rotate the gamut\n *\n * @name gamut.rotate\n * @function\n * @param {Integer} count - the number of rotations\n * @param {String|Array} gamut - a list of notes or intervals\n * @return {Array} the gamut rotated count times\n *\n * @example\n * var G = require('music-gamut')\n * G.rotate(1, 'C D E') // => ['D', 'E', 'C']\n */\ngamut.rotate = function (count, source) {\n  var g = gamut.split(source)\n  var len = g.length\n  var n = ((count % len) + len) % len\n  return g.slice(n, len).concat(g.slice(0, n))\n}\n\n/**\n * Select some elements from a gamut\n *\n * @name gamut.select\n * @function\n * @param {String|Array} numbers - a __1-based__ index of the elements\n * @param {String|Array} gamut - the notes or intervals\n * @return {Array} the selected elements\n *\n * @example\n * var gamut = require('music-gamut')\n * gamut.select('1 3 5', 'C D E F G A B') // => ['C', 'E', 'G']\n */\ngamut.select = function s (nums, src) {\n  if (arguments.length === 1) return function (g) { return s(nums, g) }\n  var g = gamut.split(src)\n  return gamut.split(nums).map(function (n) {\n    return g[n - 1]\n  })\n}\n\nif (typeof module === 'object' && module.exports) module.exports = gamut\nif (typeof window !== 'undefined') window.gamut = gamut\n"
          },
          "name": "gamut.select",
          "params": [
            {
              "title": "param",
              "description": "a __1-based__ index of the elements",
              "lineNumber": 6,
              "type": {
                "type": "UnionType",
                "elements": [
                  {
                    "type": "NameExpression",
                    "name": "String"
                  },
                  {
                    "type": "NameExpression",
                    "name": "Array"
                  }
                ]
              },
              "name": "numbers"
            },
            {
              "title": "param",
              "description": "the notes or intervals",
              "lineNumber": 7,
              "type": {
                "type": "UnionType",
                "elements": [
                  {
                    "type": "NameExpression",
                    "name": "String"
                  },
                  {
                    "type": "NameExpression",
                    "name": "Array"
                  }
                ]
              },
              "name": "gamut"
            }
          ],
          "returns": [
            {
              "title": "returns",
              "description": "the selected elements",
              "lineNumber": 8,
              "type": {
                "type": "NameExpression",
                "name": "Array"
              }
            }
          ],
          "examples": [
            "<span class=\"hljs-keyword\">var</span> gamut = <span class=\"hljs-built_in\">require</span>(<span class=\"hljs-string\">'music-gamut'</span>)\ngamut.select(<span class=\"hljs-string\">'1 3 5'</span>, <span class=\"hljs-string\">'C D E F G A B'</span>) <span class=\"hljs-comment\">// =&gt; ['C', 'E', 'G']</span>"
          ],
          "kind": "function",
          "memberof": "gamut",
          "scope": "static",
          "members": {
            "instance": [],
            "static": []
          },
          "events": [],
          "path": [
            "gamut",
            "gamut.select"
          ]
        },
        {
          "description": "Convert a source to an array. If the source is an array, return it.\n\nAside from an array itself, the source can be a\nstring with elements separated by spaces, commas or bars (`|`) or a single\nelement that will be wrapped inside an array\n\nThis function __does not perform any transformation__ of the array elements.\nand __it always return an array, even if its empty__.",
          "tags": [
            {
              "title": "name",
              "description": null,
              "lineNumber": 10,
              "name": "gamut.split"
            },
            {
              "title": "function",
              "description": null,
              "lineNumber": 11,
              "name": null
            },
            {
              "title": "param",
              "description": "the source",
              "lineNumber": 13,
              "type": {
                "type": "UnionType",
                "elements": [
                  {
                    "type": "NameExpression",
                    "name": "String"
                  },
                  {
                    "type": "NameExpression",
                    "name": "Array"
                  }
                ]
              },
              "name": "source"
            },
            {
              "title": "returns",
              "description": "the source as array",
              "lineNumber": 14,
              "type": {
                "type": "NameExpression",
                "name": "Array"
              }
            },
            {
              "title": "example",
              "description": "var G = require('music-gamut')\nG.split('a | B C , Dmaj7') // => ['a', 'B', 'C', 'Dmaj7']\nG.split() // => []",
              "lineNumber": 16
            },
            {
              "title": "kind",
              "kind": "function"
            },
            {
              "title": "memberof",
              "description": "gamut"
            },
            {
              "title": "static"
            }
          ],
          "loc": {
            "start": {
              "line": 69,
              "column": 0
            },
            "end": {
              "line": 88,
              "column": 3
            }
          },
          "context": {
            "loc": {
              "start": {
                "line": 89,
                "column": 0
              },
              "end": {
                "line": 109,
                "column": 0
              }
            },
            "file": "./packages/music-gamut/index.js",
            "code": "'use strict'\n\nvar parse = require('music-notation/pitch/parse')\nvar str = require('music-notation/pitch/str')\nvar SEP = /\\s*\\|\\s*|\\s*,\\s*|\\s+/\n\nvar isArray = Array.isArray\nfunction toStr (s) { return isArray(s) ? str(s) : s }\nfunction toArr (s) { return isArray(s) ? s : parse(s) }\n\nfunction id (e) { return e }\n\n/**\n * A gamut is a collection of intervals, pitch classes or notes.\n * Scales, chords, pitch sets are examples of gamuts.\n *\n * With this function you can manipulate music gamuts in array notation.\n *\n * @name gamut\n * @param {String|Function} operation - the operation to perfom\n * @param {String|Array} source - a list of elements\n * @return {Array} a list of pitches\n *\n * @example\n * var gamut = require('music-gamut')\n * gamut('c2 bb fx blah') // => ['C2', 'Bb', 'F##', null]\n */\nfunction gamut (op, source) {\n  if (arguments.length === 1 && typeof op !== 'function') return gamut(id, op)\n  return gamut.operation(op)(source)\n}\n\n/**\n * Given a gamut get its notes or intervals in [array notation]()\n *\n * @name gamut.parse\n * @function\n * @param {Array|String} source - the notes or intervals\n * @return {Array} the notes or intervals in array notation\n *\n * @example\n * var gamut = require('music-gamut')\n * gamut.parse('C D E') // => [ [0], [2], [4] ]\n */\ngamut.parse = function (source) {\n  return gamut.split(source).map(toArr)\n}\n\n/**\n * Decorate a function to work with gamuts.\n *\n * The function to decorate receives an array of pitches in\n * [array notation]()  and should return the desired transformed array.\n *\n * @name gamut.operation\n * @function\n * @param {Function} fn - the function to decorate\n * @return {Function} the decorated function\n */\ngamut.operation = function (fn) {\n  return function (source) {\n    var g = gamut.split(source)\n    if (isArray(g[0])) return fn(g)\n    var v = fn(g.map(parse))\n    return isArray(v) ? v.map(toStr) : v\n  }\n}\n\n/**\n * Convert a source to an array. If the source is an array, return it.\n *\n * Aside from an array itself, the source can be a\n * string with elements separated by spaces, commas or bars (`|`) or a single\n * element that will be wrapped inside an array\n *\n * This function __does not perform any transformation__ of the array elements.\n * and __it always return an array, even if its empty__.\n *\n * @name gamut.split\n * @function\n * @param {String|Array} source - the source\n * @return {Array} the source as array\n *\n * @example\n * var G = require('music-gamut')\n * G.split('a | B C , Dmaj7') // => ['a', 'B', 'C', 'Dmaj7']\n * G.split() // => []\n */\ngamut.split = function (source) {\n  if (isArray(source)) return source\n  else if (typeof source === 'string') return source.trim().split(SEP)\n  else if (source === null || typeof source === 'undefined') return []\n  else return [ source ]\n}\n\n/**\n * Rotate the gamut\n *\n * @name gamut.rotate\n * @function\n * @param {Integer} count - the number of rotations\n * @param {String|Array} gamut - a list of notes or intervals\n * @return {Array} the gamut rotated count times\n *\n * @example\n * var G = require('music-gamut')\n * G.rotate(1, 'C D E') // => ['D', 'E', 'C']\n */\ngamut.rotate = function (count, source) {\n  var g = gamut.split(source)\n  var len = g.length\n  var n = ((count % len) + len) % len\n  return g.slice(n, len).concat(g.slice(0, n))\n}\n\n/**\n * Select some elements from a gamut\n *\n * @name gamut.select\n * @function\n * @param {String|Array} numbers - a __1-based__ index of the elements\n * @param {String|Array} gamut - the notes or intervals\n * @return {Array} the selected elements\n *\n * @example\n * var gamut = require('music-gamut')\n * gamut.select('1 3 5', 'C D E F G A B') // => ['C', 'E', 'G']\n */\ngamut.select = function s (nums, src) {\n  if (arguments.length === 1) return function (g) { return s(nums, g) }\n  var g = gamut.split(src)\n  return gamut.split(nums).map(function (n) {\n    return g[n - 1]\n  })\n}\n\nif (typeof module === 'object' && module.exports) module.exports = gamut\nif (typeof window !== 'undefined') window.gamut = gamut\n"
          },
          "name": "gamut.split",
          "params": [
            {
              "title": "param",
              "description": "the source",
              "lineNumber": 13,
              "type": {
                "type": "UnionType",
                "elements": [
                  {
                    "type": "NameExpression",
                    "name": "String"
                  },
                  {
                    "type": "NameExpression",
                    "name": "Array"
                  }
                ]
              },
              "name": "source"
            }
          ],
          "returns": [
            {
              "title": "returns",
              "description": "the source as array",
              "lineNumber": 14,
              "type": {
                "type": "NameExpression",
                "name": "Array"
              }
            }
          ],
          "examples": [
            "<span class=\"hljs-keyword\">var</span> G = <span class=\"hljs-built_in\">require</span>(<span class=\"hljs-string\">'music-gamut'</span>)\nG.split(<span class=\"hljs-string\">'a | B C , Dmaj7'</span>) <span class=\"hljs-comment\">// =&gt; ['a', 'B', 'C', 'Dmaj7']</span>\nG.split() <span class=\"hljs-comment\">// =&gt; []</span>"
          ],
          "kind": "function",
          "memberof": "gamut",
          "scope": "static",
          "members": {
            "instance": [],
            "static": []
          },
          "events": [],
          "path": [
            "gamut",
            "gamut.split"
          ]
        }
      ]
    },
    "events": [],
    "path": [
      "gamut"
    ]
  },
  {
    "description": "A gamut is a collection of intervals, pitch classes or notes.\nScales, chords, pitch sets are examples of gamuts.\n\nWith this function you can manipulate music gamuts in array notation.",
    "tags": [
      {
        "title": "name",
        "description": null,
        "lineNumber": 6,
        "name": "gamut"
      },
      {
        "title": "param",
        "description": "the operation to perfom",
        "lineNumber": 7,
        "type": {
          "type": "UnionType",
          "elements": [
            {
              "type": "NameExpression",
              "name": "String"
            },
            {
              "type": "NameExpression",
              "name": "Function"
            }
          ]
        },
        "name": "operation"
      },
      {
        "title": "param",
        "description": "a list of elements",
        "lineNumber": 8,
        "type": {
          "type": "UnionType",
          "elements": [
            {
              "type": "NameExpression",
              "name": "String"
            },
            {
              "type": "NameExpression",
              "name": "Array"
            }
          ]
        },
        "name": "source"
      },
      {
        "title": "returns",
        "description": "a list of pitches",
        "lineNumber": 9,
        "type": {
          "type": "NameExpression",
          "name": "Array"
        }
      },
      {
        "title": "example",
        "description": "var gamut = require('music-gamut')\ngamut('c2 bb fx blah') // => ['C2', 'Bb', 'F##', null]",
        "lineNumber": 11
      },
      {
        "title": "kind",
        "kind": "function"
      }
    ],
    "loc": {
      "start": {
        "line": 13,
        "column": 0
      },
      "end": {
        "line": 27,
        "column": 3
      }
    },
    "context": {
      "loc": {
        "start": {
          "line": 28,
          "column": 0
        },
        "end": {
          "line": 31,
          "column": 1
        }
      },
      "file": "./packages/music-gamut/index.js",
      "code": "'use strict'\n\nvar parse = require('music-notation/pitch/parse')\nvar str = require('music-notation/pitch/str')\nvar SEP = /\\s*\\|\\s*|\\s*,\\s*|\\s+/\n\nvar isArray = Array.isArray\nfunction toStr (s) { return isArray(s) ? str(s) : s }\nfunction toArr (s) { return isArray(s) ? s : parse(s) }\n\nfunction id (e) { return e }\n\n/**\n * A gamut is a collection of intervals, pitch classes or notes.\n * Scales, chords, pitch sets are examples of gamuts.\n *\n * With this function you can manipulate music gamuts in array notation.\n *\n * @name gamut\n * @param {String|Function} operation - the operation to perfom\n * @param {String|Array} source - a list of elements\n * @return {Array} a list of pitches\n *\n * @example\n * var gamut = require('music-gamut')\n * gamut('c2 bb fx blah') // => ['C2', 'Bb', 'F##', null]\n */\nfunction gamut (op, source) {\n  if (arguments.length === 1 && typeof op !== 'function') return gamut(id, op)\n  return gamut.operation(op)(source)\n}\n\n/**\n * Given a gamut get its notes or intervals in [array notation]()\n *\n * @name gamut.parse\n * @function\n * @param {Array|String} source - the notes or intervals\n * @return {Array} the notes or intervals in array notation\n *\n * @example\n * var gamut = require('music-gamut')\n * gamut.parse('C D E') // => [ [0], [2], [4] ]\n */\ngamut.parse = function (source) {\n  return gamut.split(source).map(toArr)\n}\n\n/**\n * Decorate a function to work with gamuts.\n *\n * The function to decorate receives an array of pitches in\n * [array notation]()  and should return the desired transformed array.\n *\n * @name gamut.operation\n * @function\n * @param {Function} fn - the function to decorate\n * @return {Function} the decorated function\n */\ngamut.operation = function (fn) {\n  return function (source) {\n    var g = gamut.split(source)\n    if (isArray(g[0])) return fn(g)\n    var v = fn(g.map(parse))\n    return isArray(v) ? v.map(toStr) : v\n  }\n}\n\n/**\n * Convert a source to an array. If the source is an array, return it.\n *\n * Aside from an array itself, the source can be a\n * string with elements separated by spaces, commas or bars (`|`) or a single\n * element that will be wrapped inside an array\n *\n * This function __does not perform any transformation__ of the array elements.\n * and __it always return an array, even if its empty__.\n *\n * @name gamut.split\n * @function\n * @param {String|Array} source - the source\n * @return {Array} the source as array\n *\n * @example\n * var G = require('music-gamut')\n * G.split('a | B C , Dmaj7') // => ['a', 'B', 'C', 'Dmaj7']\n * G.split() // => []\n */\ngamut.split = function (source) {\n  if (isArray(source)) return source\n  else if (typeof source === 'string') return source.trim().split(SEP)\n  else if (source === null || typeof source === 'undefined') return []\n  else return [ source ]\n}\n\n/**\n * Rotate the gamut\n *\n * @name gamut.rotate\n * @function\n * @param {Integer} count - the number of rotations\n * @param {String|Array} gamut - a list of notes or intervals\n * @return {Array} the gamut rotated count times\n *\n * @example\n * var G = require('music-gamut')\n * G.rotate(1, 'C D E') // => ['D', 'E', 'C']\n */\ngamut.rotate = function (count, source) {\n  var g = gamut.split(source)\n  var len = g.length\n  var n = ((count % len) + len) % len\n  return g.slice(n, len).concat(g.slice(0, n))\n}\n\n/**\n * Select some elements from a gamut\n *\n * @name gamut.select\n * @function\n * @param {String|Array} numbers - a __1-based__ index of the elements\n * @param {String|Array} gamut - the notes or intervals\n * @return {Array} the selected elements\n *\n * @example\n * var gamut = require('music-gamut')\n * gamut.select('1 3 5', 'C D E F G A B') // => ['C', 'E', 'G']\n */\ngamut.select = function s (nums, src) {\n  if (arguments.length === 1) return function (g) { return s(nums, g) }\n  var g = gamut.split(src)\n  return gamut.split(nums).map(function (n) {\n    return g[n - 1]\n  })\n}\n\nif (typeof module === 'object' && module.exports) module.exports = gamut\nif (typeof window !== 'undefined') window.gamut = gamut\n"
    },
    "name": "gamut",
    "params": [
      {
        "title": "param",
        "description": "the operation to perfom",
        "lineNumber": 7,
        "type": {
          "type": "UnionType",
          "elements": [
            {
              "type": "NameExpression",
              "name": "String"
            },
            {
              "type": "NameExpression",
              "name": "Function"
            }
          ]
        },
        "name": "operation"
      },
      {
        "title": "param",
        "description": "a list of elements",
        "lineNumber": 8,
        "type": {
          "type": "UnionType",
          "elements": [
            {
              "type": "NameExpression",
              "name": "String"
            },
            {
              "type": "NameExpression",
              "name": "Array"
            }
          ]
        },
        "name": "source"
      }
    ],
    "returns": [
      {
        "title": "returns",
        "description": "a list of pitches",
        "lineNumber": 9,
        "type": {
          "type": "NameExpression",
          "name": "Array"
        }
      }
    ],
    "examples": [
      "<span class=\"hljs-keyword\">var</span> gamut = <span class=\"hljs-built_in\">require</span>(<span class=\"hljs-string\">'music-gamut'</span>)\ngamut(<span class=\"hljs-string\">'c2 bb fx blah'</span>) <span class=\"hljs-comment\">// =&gt; ['C2', 'Bb', 'F##', null]</span>"
    ],
    "kind": "function",
    "members": {
      "instance": [],
      "static": []
    },
    "events": [],
    "path": [
      "gamut"
    ]
  },
  {
    "description": "Harmonize a note using a collection of intervals or notes.\n\nThe tonic must be\na pitch (with or without octave) or false to get the intervals\n\nThis function is currified, so you can partially apply the function passing\none parameter instead of two (see example)",
    "tags": [
      {
        "title": "name",
        "description": null,
        "lineNumber": 9,
        "name": "harmonize"
      },
      {
        "title": "param",
        "description": "the list of intervals or notes",
        "lineNumber": 10,
        "type": {
          "type": "NameExpression",
          "name": "Array"
        },
        "name": "source"
      },
      {
        "title": "param",
        "description": "the tonic of the chord or null to get the intervals",
        "lineNumber": 11,
        "type": {
          "type": "NameExpression",
          "name": "String"
        },
        "name": "tonic"
      },
      {
        "title": "returns",
        "description": "the chord notes or intervals",
        "lineNumber": 12,
        "type": {
          "type": "NameExpression",
          "name": "Array"
        }
      },
      {
        "title": "example",
        "description": "var harmonize = require('note-harmonize')\nharmonize('1 3 5 6', 'G') // => ['G', 'B', 'D', 'E']\nharmonize('G B D E', false) // => ['1P', '3M', '5P', '6M']\n\n// create harmonizers:\nvar maj79 = harmonize('1 3 5 7 9')\nmaj79('A4') // => ['A4', 'C#5', 'E5', 'G#5', 'B5']",
        "lineNumber": 14
      },
      {
        "title": "kind",
        "kind": "function"
      }
    ],
    "loc": {
      "start": {
        "line": 8,
        "column": 0
      },
      "end": {
        "line": 30,
        "column": 3
      }
    },
    "context": {
      "loc": {
        "start": {
          "line": 31,
          "column": 0
        },
        "end": {
          "line": 41,
          "column": 1
        }
      },
      "file": "./packages/note-harmonizer/index.js",
      "code": "'use strict'\n\nvar parse = require('music-notation/pitch/parse')\nvar gamut = require('music-gamut')\nvar distanceTo = require('note-interval')\nvar transpose = require('note-transposer')\n\n/**\n * Harmonize a note using a collection of intervals or notes.\n *\n * The tonic must be\n * a pitch (with or without octave) or false to get the intervals\n *\n * This function is currified, so you can partially apply the function passing\n * one parameter instead of two (see example)\n *\n * @name harmonize\n * @param {Array} source - the list of intervals or notes\n * @param {String} tonic - the tonic of the chord or null to get the intervals\n * @return {Array} the chord notes or intervals\n *\n * @example\n * var harmonize = require('note-harmonize')\n * harmonize('1 3 5 6', 'G') // => ['G', 'B', 'D', 'E']\n * harmonize('G B D E', false) // => ['1P', '3M', '5P', '6M']\n *\n * // create harmonizers:\n * var maj79 = harmonize('1 3 5 7 9')\n * maj79('A4') // => ['A4', 'C#5', 'E5', 'G#5', 'B5']\n */\nfunction harmonize (source, tonic) {\n  if (arguments.length === 1) return function (t) { return harmonize(source, t) }\n  return gamut(function (g) {\n    if (tonic === null) return g\n    var base = g[0]\n    var intervals = g.map(distanceTo(base))\n    if (tonic === false) return intervals\n    tonic = parse(tonic)\n    return intervals.map(transpose(tonic))\n  }, source)\n}\n\nif (typeof module === 'object' && module.exports) module.exports = harmonize\nif (typeof window !== 'undefined') window.harmonize = harmonize\n"
    },
    "name": "harmonize",
    "params": [
      {
        "title": "param",
        "description": "the list of intervals or notes",
        "lineNumber": 10,
        "type": {
          "type": "NameExpression",
          "name": "Array"
        },
        "name": "source"
      },
      {
        "title": "param",
        "description": "the tonic of the chord or null to get the intervals",
        "lineNumber": 11,
        "type": {
          "type": "NameExpression",
          "name": "String"
        },
        "name": "tonic"
      }
    ],
    "returns": [
      {
        "title": "returns",
        "description": "the chord notes or intervals",
        "lineNumber": 12,
        "type": {
          "type": "NameExpression",
          "name": "Array"
        }
      }
    ],
    "examples": [
      "<span class=\"hljs-keyword\">var</span> harmonize = <span class=\"hljs-built_in\">require</span>(<span class=\"hljs-string\">'note-harmonize'</span>)\nharmonize(<span class=\"hljs-string\">'1 3 5 6'</span>, <span class=\"hljs-string\">'G'</span>) <span class=\"hljs-comment\">// =&gt; ['G', 'B', 'D', 'E']</span>\nharmonize(<span class=\"hljs-string\">'G B D E'</span>, <span class=\"hljs-literal\">false</span>) <span class=\"hljs-comment\">// =&gt; ['1P', '3M', '5P', '6M']</span>\n\n<span class=\"hljs-comment\">// create harmonizers:</span>\n<span class=\"hljs-keyword\">var</span> maj79 = harmonize(<span class=\"hljs-string\">'1 3 5 7 9'</span>)\nmaj79(<span class=\"hljs-string\">'A4'</span>) <span class=\"hljs-comment\">// =&gt; ['A4', 'C#5', 'E5', 'G#5', 'B5']</span>"
    ],
    "kind": "function",
    "members": {
      "instance": [],
      "static": []
    },
    "events": [],
    "path": [
      "harmonize"
    ]
  },
  {
    "description": "Get the intervals analysis of a collection of notes\n\nReturns an array with the format `[p, m, n, s, d, t]` where:\n\n- p: the number of perfect fourths or fifths\n- m: the number of major thirds or minor sixths\n- n: the number of major sixths or minor thirds\n- s: the number of major seconds or minor sevenths\n- d: the number of major sevents or minor seconds\n- t: the number of tritones\n\nThis is, mostly, an academic puzzle to show the expresiveness of tonal.\nImplements the ideas found in \"The Analysis of Intervals\" chapter from\n[Harmonic Materials of Modern Music]():\n\n> The letters _pmn_, therefore, represent intervals commonly considered\nconsonant, whereas the letters _sdt_ represent the intervals commonly\nconsidered dissonant. (...) A sonority represented, for example, by the\nsymbol `sd^2`, indicating a triad composed of one major second and two minor\nseconds, would be recognized as a highly dissonant sound, while the symbol\n`pmn` would indicate a consonant sound.",
    "tags": [
      {
        "title": "name",
        "description": null,
        "lineNumber": 23,
        "name": "interval.density"
      },
      {
        "title": "function",
        "description": null,
        "lineNumber": 24,
        "name": null
      },
      {
        "title": "param",
        "description": "the notes to analyze",
        "lineNumber": 26,
        "type": {
          "type": "UnionType",
          "elements": [
            {
              "type": "NameExpression",
              "name": "Array"
            },
            {
              "type": "NameExpression",
              "name": "String"
            }
          ]
        },
        "name": "notes"
      },
      {
        "title": "returns",
        "description": "the _pmnsdt_ array",
        "lineNumber": 27,
        "type": {
          "type": "NameExpression",
          "name": "Array"
        }
      },
      {
        "title": "kind",
        "kind": "function"
      },
      {
        "title": "memberof",
        "description": "module"
      },
      {
        "title": "static"
      }
    ],
    "loc": {
      "start": {
        "line": 8,
        "column": 0
      },
      "end": {
        "line": 35,
        "column": 3
      }
    },
    "context": {
      "loc": {
        "start": {
          "line": 36,
          "column": 0
        },
        "end": {
          "line": 50,
          "column": 0
        }
      },
      "file": "./packages/interval-density/index.js",
      "code": "'use strict'\n\nvar gamut = require('music-gamut')\nvar semitones = require('semitones')\nvar ic = require('interval-class')\nfunction isNote (a) { return a.length !== 2 }\n\n/**\n * Get the intervals analysis of a collection of notes\n *\n * Returns an array with the format `[p, m, n, s, d, t]` where:\n *\n * - p: the number of perfect fourths or fifths\n * - m: the number of major thirds or minor sixths\n * - n: the number of major sixths or minor thirds\n * - s: the number of major seconds or minor sevenths\n * - d: the number of major sevents or minor seconds\n * - t: the number of tritones\n *\n * This is, mostly, an academic puzzle to show the expresiveness of tonal.\n * Implements the ideas found in \"The Analysis of Intervals\" chapter from\n * [Harmonic Materials of Modern Music]():\n *\n * > The letters _pmn_, therefore, represent intervals commonly considered\n * consonant, whereas the letters _sdt_ represent the intervals commonly\n * considered dissonant. (...) A sonority represented, for example, by the\n * symbol `sd^2`, indicating a triad composed of one major second and two minor\n * seconds, would be recognized as a highly dissonant sound, while the symbol\n * `pmn` would indicate a consonant sound.\n *\n * @name interval.density\n * @function\n * @param {Array|String} notes - the notes to analyze\n * @return {Array} the _pmnsdt_ array\n */\nmodule.exports = function (notes) {\n  var a, b, i\n  notes = gamut.parse(notes).filter(isNote)\n  var len = notes.length\n  var result = [0, 0, 0, 0, 0, 0]\n  for (a = 0; a < len; a++) {\n    for (b = a; b < len; b++) {\n      i = ic(semitones(notes[b]) - semitones(notes[a]))\n      if (i === 6) result[5] = result[5] + 1\n      else if (i > 0) result[5 - i] = result[5 - i] + 1\n    }\n  }\n  return result\n}\n"
    },
    "name": "interval.density",
    "params": [
      {
        "title": "param",
        "description": "the notes to analyze",
        "lineNumber": 26,
        "type": {
          "type": "UnionType",
          "elements": [
            {
              "type": "NameExpression",
              "name": "Array"
            },
            {
              "type": "NameExpression",
              "name": "String"
            }
          ]
        },
        "name": "notes"
      }
    ],
    "returns": [
      {
        "title": "returns",
        "description": "the _pmnsdt_ array",
        "lineNumber": 27,
        "type": {
          "type": "NameExpression",
          "name": "Array"
        }
      }
    ],
    "kind": "function",
    "memberof": "module",
    "scope": "static",
    "members": {
      "instance": [],
      "static": []
    },
    "events": [],
    "path": [
      "interval.density"
    ]
  },
  {
    "description": "Get the [interval class](https://en.wikipedia.org/wiki/Interval_class)\nnumber of a given interval.\n\nIn musical set theory, an interval class is the shortest distance in\npitch class space between two unordered pitch classes\n\nAs paramter you can pass an interval in shorthand notation, an interval in\narray notation or the number of semitones of the interval",
    "tags": [
      {
        "title": "name",
        "description": null,
        "lineNumber": 10,
        "name": "intervalClass"
      },
      {
        "title": "function",
        "description": null,
        "lineNumber": 11,
        "name": null
      },
      {
        "title": "param",
        "description": "the interval or the number of semitones",
        "lineNumber": 13,
        "type": {
          "type": "UnionType",
          "elements": [
            {
              "type": "NameExpression",
              "name": "String"
            },
            {
              "type": "NameExpression",
              "name": "Integer"
            }
          ]
        },
        "name": "interval"
      },
      {
        "title": "returns",
        "description": "A value between 0 and 6",
        "lineNumber": 14,
        "type": {
          "type": "NameExpression",
          "name": "Integer"
        }
      },
      {
        "title": "example",
        "description": "var ic = require('interal-class')\nic('P8') // => 0\nic('m6') // => 4\n['P1', 'M2', 'M3', 'P4', 'P5', 'M6', 'M7'].map(ic) // => [0, 2, 4, 5, 5, 3, 1]",
        "lineNumber": 16
      },
      {
        "title": "kind",
        "kind": "function"
      },
      {
        "title": "memberof",
        "description": "module"
      },
      {
        "title": "static"
      }
    ],
    "loc": {
      "start": {
        "line": 6,
        "column": 0
      },
      "end": {
        "line": 26,
        "column": 3
      }
    },
    "context": {
      "loc": {
        "start": {
          "line": 27,
          "column": 0
        },
        "end": {
          "line": 31,
          "column": 0
        }
      },
      "file": "./packages/interval-class/index.js",
      "code": "'use strict'\n\nvar semitones = require('semitones')\nvar CLASSES = [0, 1, 2, 3, 4, 5, 6, 5, 4, 3, 2, 1]\n\n/**\n * Get the [interval class](https://en.wikipedia.org/wiki/Interval_class)\n * number of a given interval.\n *\n * In musical set theory, an interval class is the shortest distance in\n * pitch class space between two unordered pitch classes\n *\n * As paramter you can pass an interval in shorthand notation, an interval in\n * array notation or the number of semitones of the interval\n *\n * @name intervalClass\n * @function\n * @param {String|Integer} interval - the interval or the number of semitones\n * @return {Integer} A value between 0 and 6\n *\n * @example\n * var ic = require('interal-class')\n * ic('P8') // => 0\n * ic('m6') // => 4\n * ['P1', 'M2', 'M3', 'P4', 'P5', 'M6', 'M7'].map(ic) // => [0, 2, 4, 5, 5, 3, 1]\n */\nmodule.exports = function (ivl) {\n  var s = typeof ivl === 'string' ? semitones(ivl) : Math.round(ivl)\n  return s !== null ? CLASSES[Math.abs(s) % 12] : null\n}\n"
    },
    "name": "intervalClass",
    "params": [
      {
        "title": "param",
        "description": "the interval or the number of semitones",
        "lineNumber": 13,
        "type": {
          "type": "UnionType",
          "elements": [
            {
              "type": "NameExpression",
              "name": "String"
            },
            {
              "type": "NameExpression",
              "name": "Integer"
            }
          ]
        },
        "name": "interval"
      }
    ],
    "returns": [
      {
        "title": "returns",
        "description": "A value between 0 and 6",
        "lineNumber": 14,
        "type": {
          "type": "NameExpression",
          "name": "Integer"
        }
      }
    ],
    "examples": [
      "<span class=\"hljs-keyword\">var</span> ic = <span class=\"hljs-built_in\">require</span>(<span class=\"hljs-string\">'interal-class'</span>)\nic(<span class=\"hljs-string\">'P8'</span>) <span class=\"hljs-comment\">// =&gt; 0</span>\nic(<span class=\"hljs-string\">'m6'</span>) <span class=\"hljs-comment\">// =&gt; 4</span>\n[<span class=\"hljs-string\">'P1'</span>, <span class=\"hljs-string\">'M2'</span>, <span class=\"hljs-string\">'M3'</span>, <span class=\"hljs-string\">'P4'</span>, <span class=\"hljs-string\">'P5'</span>, <span class=\"hljs-string\">'M6'</span>, <span class=\"hljs-string\">'M7'</span>].map(ic) <span class=\"hljs-comment\">// =&gt; [0, 2, 4, 5, 5, 3, 1]</span>"
    ],
    "kind": "function",
    "memberof": "module",
    "scope": "static",
    "members": {
      "instance": [],
      "static": []
    },
    "events": [],
    "path": [
      "intervalClass"
    ]
  },
  {
    "description": "Create a key from a string. A key is a string with a tonic and a mode",
    "tags": [
      {
        "title": "name",
        "description": null,
        "lineNumber": 3,
        "name": "key"
      },
      {
        "title": "function",
        "description": null,
        "lineNumber": 4,
        "name": null
      },
      {
        "title": "example",
        "description": "var key = require('music-key')\nkey('C major') // => 'C major'\nkey('c Major') // => 'C major'\nkey('C') // => 'C major'\nkey('dbb miXolydian') // => 'Dbb mixolydian'",
        "lineNumber": 8
      },
      {
        "title": "kind",
        "kind": "function"
      }
    ],
    "loc": {
      "start": {
        "line": 17,
        "column": 0
      },
      "end": {
        "line": 29,
        "column": 3
      }
    },
    "context": {
      "loc": {
        "start": {
          "line": 30,
          "column": 0
        },
        "end": {
          "line": 40,
          "column": 1
        }
      },
      "file": "./packages/music-key/index.js",
      "code": "'use strict'\n\nvar transpose = require('note-transposer')\nvar interval = require('note-interval')\nvar parse = require('music-notation/note/parse')\nvar parseI = require('music-notation/interval/parse')\nvar str = require('music-notation/note/str')\n\nvar REGEX = /^#{1,7}|b{1,7}$/\nvar KEYS = { major: 1, minor: 6, ionian: 1, dorian: 2, phrygian: 3, lydian: 4,\n  mixolydian: 5, aeolian: 6, locrian: 7 }\nvar SCALES = [\n  '1 2 3 4 5 6 7', '1 2 3b 4 5 6 7b', '1 2b 3b 4 5 6b 7b', '1 2 3 4# 5 6 7',\n  '1 2 3 4 5 6 7b', '1 2 3b 4 5 6b 7b', '1 2b 3b 4 5b 6b 7b'\n].map(function (g) { return g.split(' ') })\n\n/**\n * Create a key from a string. A key is a string with a tonic and a mode\n *\n * @name key\n * @function\n *\n * @example\n * var key = require('music-key')\n * key('C major') // => 'C major'\n * key('c Major') // => 'C major'\n * key('C') // => 'C major'\n * key('dbb miXolydian') // => 'Dbb mixolydian'\n */\nfunction Key (str) {\n  if (/^-?\\d$/.exec(str)) {\n    return major(+str)\n  } else if (REGEX.exec(str)) {\n    var dir = str[0] === 'b' ? -1 : 1\n    return major(str.length * dir)\n  } else {\n    var p = Key.parse(str)\n    return p ? p.tonic + ' ' + p.mode : null\n  }\n}\nfunction major (n) { return transpose('C', [n, 0]) + ' major' }\n\n/**\n * Parse a key name\n *\n * @name key.parse\n * @function\n * @param {String} name - the key name\n * @return {Array} an array with the tonic and mode or null if not valid key\n *\n * @example\n * var key = require('music-key')\n * key.parse('C major') // => ['C', 'major']\n * key.parse('fx MINOR') // => ['F##', 'minor']\n * key.parse('Ab mixolydian') // => ['Ab', 'mixolydian']\n * key.parse('f bebop') // => 'null'\n */\nKey.parse = function (name) {\n  var m, s, t\n  if (!name) return null\n  s = name.trim().split(/\\s+/)\n  t = str(parse((s[0])))\n  if (s.length === 1) {\n    m = s[0].toLowerCase()\n    if (KEYS[m]) return k(null, m)\n    else if (t) return k(t, 'major')\n    else return null\n  }\n  m = s[1].toLowerCase()\n  if (t && KEYS[m]) return k(t, m)\n  return null\n}\n\nfunction k (t, m) { return {tonic: t || false, mode: m, alt: KEYS[m]} }\n\n/**\n * Get relative of a key\n *\n * This function is currified, so it can be partially applied (see examples)\n *\n * @name key.relative\n * @function\n * @param {String} relative - the name of the relative mode desired\n * @param {String} key - the key name\n * @return {String} the relative key name or null if the key or the relative name\n * are not valid\n *\n * @example\n * var key = require('music-key')\n * key.relative('minor', 'C major') // => 'A minor'\n * key.relative('major', 'A minor') // => 'C major'\n * key.relative('dorian', 'F major') // => 'G dorian'\n *\n * // partially application\n * var minorOf = key.relative('minor')\n * minorOf('Bb major') // => 'G minor'\n */\nKey.relative = function (rel, key) {\n  if (arguments.length === 1) return function (k) { return Key.relative(rel, k) }\n  var k = Key.parse(key)\n  var r = Key.parse(rel)\n  if (!k || !k.tonic || !r) return null\n  var major = k.mode === 'major' ? k.tonic : transpose(k.tonic, '-' + k.alt)\n  return r.mode === 'major' ? major + ' major' : transpose(major, '' + r.alt) + ' ' + rel\n}\n\n/**\n * Get the number of alterations of a key\n *\n * @name key.alteratons\n * @function\n * @param {String} name - the key name\n * @return {Integer} the number of alterations or null if not valid key\n *\n * @example\n * var key = require('music-key')\n * key.alterations('C major') // => 0\n * key.alterations('F major') // => -1\n * key.alterations('Eb major') // => -3\n * key.alterations('A major') // => 3\n * key.alterations('nonsense') // => null\n */\nKey.alterations = function (key) {\n  var k = Key.relative('major', key)\n  return k ? parseI(interval('C', k.split(' ')[0]))[0] : null\n}\n\n/**\n * Get signature of a key\n *\n * @name key.signature\n * @function\n * @param {String} name - the key name\n * @return {String} a string with the alterations\n *\n * @example\n * var key = require('music-key')\n * key.signature('F major') // => 'b'\n * key.signature('Eb major') // => 'bbb'\n * key.signature('A major') // => '###'\n * key.signature('C major') // => ''\n * key.signature('nonsense') // => null\n */\nKey.signature = function (key) {\n  var n = Key.alterations(key)\n  return n !== null ? new Array(Math.abs(n) + 1).join(n < 0 ? 'b' : '#') : null\n}\n\n/**\n * Get a list of altered notes in the appropriate order\n *\n * @name key.altered\n * @function\n * @param {String} name - the key name\n * @return {Array} an array with the altered notes ordered or an empty array\n * if its not a valid key name\n *\n * @example\n * key.altered('F major') // => ['Bb']\n * key.altered('Eb major') // => ['Bb', 'Eb', 'Ab']\n * key.altered('A major') // => ['F#', 'C#', 'G#']\n */\nKey.altered = function (k) {\n  var a = Key.alterations(k)\n  if (a === null) return null\n  var notes = []\n  var tonic = a > 0 ? 'B' : 'F'\n  var interval = a > 0 ? [1, 0] : [-1, 0]\n  var l = Math.abs(a)\n  for (var i = 0; i < l; i++) {\n    tonic = transpose(tonic, interval)\n    notes.push(tonic)\n  }\n  return notes\n}\n\n/**\n * Get the scale of a key\n *\n * @name key.scale\n * @function\n *\n * @example\n * var key = require('music-key')\n * key.scale('C major') // => ['C', 'D', 'E', ...]\n */\nKey.scale = function (name) {\n  var k = Key.parse(name)\n  if (!k) return []\n  return SCALES[k.alt - 1].map(transpose(k.tonic))\n}\n\nmodule.exports = Key\n"
    },
    "name": "key",
    "examples": [
      "<span class=\"hljs-keyword\">var</span> key = <span class=\"hljs-built_in\">require</span>(<span class=\"hljs-string\">'music-key'</span>)\nkey(<span class=\"hljs-string\">'C major'</span>) <span class=\"hljs-comment\">// =&gt; 'C major'</span>\nkey(<span class=\"hljs-string\">'c Major'</span>) <span class=\"hljs-comment\">// =&gt; 'C major'</span>\nkey(<span class=\"hljs-string\">'C'</span>) <span class=\"hljs-comment\">// =&gt; 'C major'</span>\nkey(<span class=\"hljs-string\">'dbb miXolydian'</span>) <span class=\"hljs-comment\">// =&gt; 'Dbb mixolydian'</span>"
    ],
    "kind": "function",
    "members": {
      "instance": [],
      "static": []
    },
    "events": [],
    "path": [
      "key"
    ]
  },
  {
    "description": "Get the number of alterations of a key",
    "tags": [
      {
        "title": "name",
        "description": null,
        "lineNumber": 3,
        "name": "key.alteratons"
      },
      {
        "title": "function",
        "description": null,
        "lineNumber": 4,
        "name": null
      },
      {
        "title": "param",
        "description": "the key name",
        "lineNumber": 6,
        "type": {
          "type": "NameExpression",
          "name": "String"
        },
        "name": "name"
      },
      {
        "title": "returns",
        "description": "the number of alterations or null if not valid key",
        "lineNumber": 7,
        "type": {
          "type": "NameExpression",
          "name": "Integer"
        }
      },
      {
        "title": "example",
        "description": "var key = require('music-key')\nkey.alterations('C major') // => 0\nkey.alterations('F major') // => -1\nkey.alterations('Eb major') // => -3\nkey.alterations('A major') // => 3\nkey.alterations('nonsense') // => null",
        "lineNumber": 9
      },
      {
        "title": "kind",
        "kind": "function"
      },
      {
        "title": "memberof",
        "description": "Key"
      },
      {
        "title": "static"
      }
    ],
    "loc": {
      "start": {
        "line": 107,
        "column": 0
      },
      "end": {
        "line": 122,
        "column": 3
      }
    },
    "context": {
      "loc": {
        "start": {
          "line": 123,
          "column": 0
        },
        "end": {
          "line": 144,
          "column": 0
        }
      },
      "file": "./packages/music-key/index.js",
      "code": "'use strict'\n\nvar transpose = require('note-transposer')\nvar interval = require('note-interval')\nvar parse = require('music-notation/note/parse')\nvar parseI = require('music-notation/interval/parse')\nvar str = require('music-notation/note/str')\n\nvar REGEX = /^#{1,7}|b{1,7}$/\nvar KEYS = { major: 1, minor: 6, ionian: 1, dorian: 2, phrygian: 3, lydian: 4,\n  mixolydian: 5, aeolian: 6, locrian: 7 }\nvar SCALES = [\n  '1 2 3 4 5 6 7', '1 2 3b 4 5 6 7b', '1 2b 3b 4 5 6b 7b', '1 2 3 4# 5 6 7',\n  '1 2 3 4 5 6 7b', '1 2 3b 4 5 6b 7b', '1 2b 3b 4 5b 6b 7b'\n].map(function (g) { return g.split(' ') })\n\n/**\n * Create a key from a string. A key is a string with a tonic and a mode\n *\n * @name key\n * @function\n *\n * @example\n * var key = require('music-key')\n * key('C major') // => 'C major'\n * key('c Major') // => 'C major'\n * key('C') // => 'C major'\n * key('dbb miXolydian') // => 'Dbb mixolydian'\n */\nfunction Key (str) {\n  if (/^-?\\d$/.exec(str)) {\n    return major(+str)\n  } else if (REGEX.exec(str)) {\n    var dir = str[0] === 'b' ? -1 : 1\n    return major(str.length * dir)\n  } else {\n    var p = Key.parse(str)\n    return p ? p.tonic + ' ' + p.mode : null\n  }\n}\nfunction major (n) { return transpose('C', [n, 0]) + ' major' }\n\n/**\n * Parse a key name\n *\n * @name key.parse\n * @function\n * @param {String} name - the key name\n * @return {Array} an array with the tonic and mode or null if not valid key\n *\n * @example\n * var key = require('music-key')\n * key.parse('C major') // => ['C', 'major']\n * key.parse('fx MINOR') // => ['F##', 'minor']\n * key.parse('Ab mixolydian') // => ['Ab', 'mixolydian']\n * key.parse('f bebop') // => 'null'\n */\nKey.parse = function (name) {\n  var m, s, t\n  if (!name) return null\n  s = name.trim().split(/\\s+/)\n  t = str(parse((s[0])))\n  if (s.length === 1) {\n    m = s[0].toLowerCase()\n    if (KEYS[m]) return k(null, m)\n    else if (t) return k(t, 'major')\n    else return null\n  }\n  m = s[1].toLowerCase()\n  if (t && KEYS[m]) return k(t, m)\n  return null\n}\n\nfunction k (t, m) { return {tonic: t || false, mode: m, alt: KEYS[m]} }\n\n/**\n * Get relative of a key\n *\n * This function is currified, so it can be partially applied (see examples)\n *\n * @name key.relative\n * @function\n * @param {String} relative - the name of the relative mode desired\n * @param {String} key - the key name\n * @return {String} the relative key name or null if the key or the relative name\n * are not valid\n *\n * @example\n * var key = require('music-key')\n * key.relative('minor', 'C major') // => 'A minor'\n * key.relative('major', 'A minor') // => 'C major'\n * key.relative('dorian', 'F major') // => 'G dorian'\n *\n * // partially application\n * var minorOf = key.relative('minor')\n * minorOf('Bb major') // => 'G minor'\n */\nKey.relative = function (rel, key) {\n  if (arguments.length === 1) return function (k) { return Key.relative(rel, k) }\n  var k = Key.parse(key)\n  var r = Key.parse(rel)\n  if (!k || !k.tonic || !r) return null\n  var major = k.mode === 'major' ? k.tonic : transpose(k.tonic, '-' + k.alt)\n  return r.mode === 'major' ? major + ' major' : transpose(major, '' + r.alt) + ' ' + rel\n}\n\n/**\n * Get the number of alterations of a key\n *\n * @name key.alteratons\n * @function\n * @param {String} name - the key name\n * @return {Integer} the number of alterations or null if not valid key\n *\n * @example\n * var key = require('music-key')\n * key.alterations('C major') // => 0\n * key.alterations('F major') // => -1\n * key.alterations('Eb major') // => -3\n * key.alterations('A major') // => 3\n * key.alterations('nonsense') // => null\n */\nKey.alterations = function (key) {\n  var k = Key.relative('major', key)\n  return k ? parseI(interval('C', k.split(' ')[0]))[0] : null\n}\n\n/**\n * Get signature of a key\n *\n * @name key.signature\n * @function\n * @param {String} name - the key name\n * @return {String} a string with the alterations\n *\n * @example\n * var key = require('music-key')\n * key.signature('F major') // => 'b'\n * key.signature('Eb major') // => 'bbb'\n * key.signature('A major') // => '###'\n * key.signature('C major') // => ''\n * key.signature('nonsense') // => null\n */\nKey.signature = function (key) {\n  var n = Key.alterations(key)\n  return n !== null ? new Array(Math.abs(n) + 1).join(n < 0 ? 'b' : '#') : null\n}\n\n/**\n * Get a list of altered notes in the appropriate order\n *\n * @name key.altered\n * @function\n * @param {String} name - the key name\n * @return {Array} an array with the altered notes ordered or an empty array\n * if its not a valid key name\n *\n * @example\n * key.altered('F major') // => ['Bb']\n * key.altered('Eb major') // => ['Bb', 'Eb', 'Ab']\n * key.altered('A major') // => ['F#', 'C#', 'G#']\n */\nKey.altered = function (k) {\n  var a = Key.alterations(k)\n  if (a === null) return null\n  var notes = []\n  var tonic = a > 0 ? 'B' : 'F'\n  var interval = a > 0 ? [1, 0] : [-1, 0]\n  var l = Math.abs(a)\n  for (var i = 0; i < l; i++) {\n    tonic = transpose(tonic, interval)\n    notes.push(tonic)\n  }\n  return notes\n}\n\n/**\n * Get the scale of a key\n *\n * @name key.scale\n * @function\n *\n * @example\n * var key = require('music-key')\n * key.scale('C major') // => ['C', 'D', 'E', ...]\n */\nKey.scale = function (name) {\n  var k = Key.parse(name)\n  if (!k) return []\n  return SCALES[k.alt - 1].map(transpose(k.tonic))\n}\n\nmodule.exports = Key\n"
    },
    "name": "key.alteratons",
    "params": [
      {
        "title": "param",
        "description": "the key name",
        "lineNumber": 6,
        "type": {
          "type": "NameExpression",
          "name": "String"
        },
        "name": "name"
      }
    ],
    "returns": [
      {
        "title": "returns",
        "description": "the number of alterations or null if not valid key",
        "lineNumber": 7,
        "type": {
          "type": "NameExpression",
          "name": "Integer"
        }
      }
    ],
    "examples": [
      "<span class=\"hljs-keyword\">var</span> key = <span class=\"hljs-built_in\">require</span>(<span class=\"hljs-string\">'music-key'</span>)\nkey.alterations(<span class=\"hljs-string\">'C major'</span>) <span class=\"hljs-comment\">// =&gt; 0</span>\nkey.alterations(<span class=\"hljs-string\">'F major'</span>) <span class=\"hljs-comment\">// =&gt; -1</span>\nkey.alterations(<span class=\"hljs-string\">'Eb major'</span>) <span class=\"hljs-comment\">// =&gt; -3</span>\nkey.alterations(<span class=\"hljs-string\">'A major'</span>) <span class=\"hljs-comment\">// =&gt; 3</span>\nkey.alterations(<span class=\"hljs-string\">'nonsense'</span>) <span class=\"hljs-comment\">// =&gt; null</span>"
    ],
    "kind": "function",
    "memberof": "Key",
    "scope": "static",
    "members": {
      "instance": [],
      "static": []
    },
    "events": [],
    "path": [
      "key.alteratons"
    ]
  },
  {
    "description": "Get a list of altered notes in the appropriate order",
    "tags": [
      {
        "title": "name",
        "description": null,
        "lineNumber": 3,
        "name": "key.altered"
      },
      {
        "title": "function",
        "description": null,
        "lineNumber": 4,
        "name": null
      },
      {
        "title": "param",
        "description": "the key name",
        "lineNumber": 6,
        "type": {
          "type": "NameExpression",
          "name": "String"
        },
        "name": "name"
      },
      {
        "title": "returns",
        "description": "an array with the altered notes ordered or an empty array\nif its not a valid key name",
        "lineNumber": 7,
        "type": {
          "type": "NameExpression",
          "name": "Array"
        }
      },
      {
        "title": "example",
        "description": "key.altered('F major') // => ['Bb']\nkey.altered('Eb major') // => ['Bb', 'Eb', 'Ab']\nkey.altered('A major') // => ['F#', 'C#', 'G#']",
        "lineNumber": 10
      },
      {
        "title": "kind",
        "kind": "function"
      },
      {
        "title": "memberof",
        "description": "Key"
      },
      {
        "title": "static"
      }
    ],
    "loc": {
      "start": {
        "line": 149,
        "column": 0
      },
      "end": {
        "line": 162,
        "column": 3
      }
    },
    "context": {
      "loc": {
        "start": {
          "line": 163,
          "column": 0
        },
        "end": {
          "line": 187,
          "column": 0
        }
      },
      "file": "./packages/music-key/index.js",
      "code": "'use strict'\n\nvar transpose = require('note-transposer')\nvar interval = require('note-interval')\nvar parse = require('music-notation/note/parse')\nvar parseI = require('music-notation/interval/parse')\nvar str = require('music-notation/note/str')\n\nvar REGEX = /^#{1,7}|b{1,7}$/\nvar KEYS = { major: 1, minor: 6, ionian: 1, dorian: 2, phrygian: 3, lydian: 4,\n  mixolydian: 5, aeolian: 6, locrian: 7 }\nvar SCALES = [\n  '1 2 3 4 5 6 7', '1 2 3b 4 5 6 7b', '1 2b 3b 4 5 6b 7b', '1 2 3 4# 5 6 7',\n  '1 2 3 4 5 6 7b', '1 2 3b 4 5 6b 7b', '1 2b 3b 4 5b 6b 7b'\n].map(function (g) { return g.split(' ') })\n\n/**\n * Create a key from a string. A key is a string with a tonic and a mode\n *\n * @name key\n * @function\n *\n * @example\n * var key = require('music-key')\n * key('C major') // => 'C major'\n * key('c Major') // => 'C major'\n * key('C') // => 'C major'\n * key('dbb miXolydian') // => 'Dbb mixolydian'\n */\nfunction Key (str) {\n  if (/^-?\\d$/.exec(str)) {\n    return major(+str)\n  } else if (REGEX.exec(str)) {\n    var dir = str[0] === 'b' ? -1 : 1\n    return major(str.length * dir)\n  } else {\n    var p = Key.parse(str)\n    return p ? p.tonic + ' ' + p.mode : null\n  }\n}\nfunction major (n) { return transpose('C', [n, 0]) + ' major' }\n\n/**\n * Parse a key name\n *\n * @name key.parse\n * @function\n * @param {String} name - the key name\n * @return {Array} an array with the tonic and mode or null if not valid key\n *\n * @example\n * var key = require('music-key')\n * key.parse('C major') // => ['C', 'major']\n * key.parse('fx MINOR') // => ['F##', 'minor']\n * key.parse('Ab mixolydian') // => ['Ab', 'mixolydian']\n * key.parse('f bebop') // => 'null'\n */\nKey.parse = function (name) {\n  var m, s, t\n  if (!name) return null\n  s = name.trim().split(/\\s+/)\n  t = str(parse((s[0])))\n  if (s.length === 1) {\n    m = s[0].toLowerCase()\n    if (KEYS[m]) return k(null, m)\n    else if (t) return k(t, 'major')\n    else return null\n  }\n  m = s[1].toLowerCase()\n  if (t && KEYS[m]) return k(t, m)\n  return null\n}\n\nfunction k (t, m) { return {tonic: t || false, mode: m, alt: KEYS[m]} }\n\n/**\n * Get relative of a key\n *\n * This function is currified, so it can be partially applied (see examples)\n *\n * @name key.relative\n * @function\n * @param {String} relative - the name of the relative mode desired\n * @param {String} key - the key name\n * @return {String} the relative key name or null if the key or the relative name\n * are not valid\n *\n * @example\n * var key = require('music-key')\n * key.relative('minor', 'C major') // => 'A minor'\n * key.relative('major', 'A minor') // => 'C major'\n * key.relative('dorian', 'F major') // => 'G dorian'\n *\n * // partially application\n * var minorOf = key.relative('minor')\n * minorOf('Bb major') // => 'G minor'\n */\nKey.relative = function (rel, key) {\n  if (arguments.length === 1) return function (k) { return Key.relative(rel, k) }\n  var k = Key.parse(key)\n  var r = Key.parse(rel)\n  if (!k || !k.tonic || !r) return null\n  var major = k.mode === 'major' ? k.tonic : transpose(k.tonic, '-' + k.alt)\n  return r.mode === 'major' ? major + ' major' : transpose(major, '' + r.alt) + ' ' + rel\n}\n\n/**\n * Get the number of alterations of a key\n *\n * @name key.alteratons\n * @function\n * @param {String} name - the key name\n * @return {Integer} the number of alterations or null if not valid key\n *\n * @example\n * var key = require('music-key')\n * key.alterations('C major') // => 0\n * key.alterations('F major') // => -1\n * key.alterations('Eb major') // => -3\n * key.alterations('A major') // => 3\n * key.alterations('nonsense') // => null\n */\nKey.alterations = function (key) {\n  var k = Key.relative('major', key)\n  return k ? parseI(interval('C', k.split(' ')[0]))[0] : null\n}\n\n/**\n * Get signature of a key\n *\n * @name key.signature\n * @function\n * @param {String} name - the key name\n * @return {String} a string with the alterations\n *\n * @example\n * var key = require('music-key')\n * key.signature('F major') // => 'b'\n * key.signature('Eb major') // => 'bbb'\n * key.signature('A major') // => '###'\n * key.signature('C major') // => ''\n * key.signature('nonsense') // => null\n */\nKey.signature = function (key) {\n  var n = Key.alterations(key)\n  return n !== null ? new Array(Math.abs(n) + 1).join(n < 0 ? 'b' : '#') : null\n}\n\n/**\n * Get a list of altered notes in the appropriate order\n *\n * @name key.altered\n * @function\n * @param {String} name - the key name\n * @return {Array} an array with the altered notes ordered or an empty array\n * if its not a valid key name\n *\n * @example\n * key.altered('F major') // => ['Bb']\n * key.altered('Eb major') // => ['Bb', 'Eb', 'Ab']\n * key.altered('A major') // => ['F#', 'C#', 'G#']\n */\nKey.altered = function (k) {\n  var a = Key.alterations(k)\n  if (a === null) return null\n  var notes = []\n  var tonic = a > 0 ? 'B' : 'F'\n  var interval = a > 0 ? [1, 0] : [-1, 0]\n  var l = Math.abs(a)\n  for (var i = 0; i < l; i++) {\n    tonic = transpose(tonic, interval)\n    notes.push(tonic)\n  }\n  return notes\n}\n\n/**\n * Get the scale of a key\n *\n * @name key.scale\n * @function\n *\n * @example\n * var key = require('music-key')\n * key.scale('C major') // => ['C', 'D', 'E', ...]\n */\nKey.scale = function (name) {\n  var k = Key.parse(name)\n  if (!k) return []\n  return SCALES[k.alt - 1].map(transpose(k.tonic))\n}\n\nmodule.exports = Key\n"
    },
    "name": "key.altered",
    "params": [
      {
        "title": "param",
        "description": "the key name",
        "lineNumber": 6,
        "type": {
          "type": "NameExpression",
          "name": "String"
        },
        "name": "name"
      }
    ],
    "returns": [
      {
        "title": "returns",
        "description": "an array with the altered notes ordered or an empty array\nif its not a valid key name",
        "lineNumber": 7,
        "type": {
          "type": "NameExpression",
          "name": "Array"
        }
      }
    ],
    "examples": [
      "key.altered(<span class=\"hljs-string\">'F major'</span>) <span class=\"hljs-comment\">// =&gt; ['Bb']</span>\nkey.altered(<span class=\"hljs-string\">'Eb major'</span>) <span class=\"hljs-comment\">// =&gt; ['Bb', 'Eb', 'Ab']</span>\nkey.altered(<span class=\"hljs-string\">'A major'</span>) <span class=\"hljs-comment\">// =&gt; ['F#', 'C#', 'G#']</span>"
    ],
    "kind": "function",
    "memberof": "Key",
    "scope": "static",
    "members": {
      "instance": [],
      "static": []
    },
    "events": [],
    "path": [
      "key.altered"
    ]
  },
  {
    "description": "Get chords of a key",
    "tags": [
      {
        "title": "name",
        "description": null,
        "lineNumber": 3,
        "name": "key.chords"
      },
      {
        "title": "function",
        "description": null,
        "lineNumber": 4,
        "name": null
      },
      {
        "title": "param",
        "description": "the key name",
        "lineNumber": 6,
        "type": {
          "type": "NameExpression",
          "name": "String"
        },
        "name": "name"
      },
      {
        "title": "returns",
        "description": "an array with the key chords",
        "lineNumber": 7,
        "type": {
          "type": "NameExpression",
          "name": "Array"
        }
      },
      {
        "title": "example",
        "description": "key.chords('C major') // => ['C', 'Dm', 'Em', 'F', 'G7', 'Am', 'Bo'\nkey.chords('major', false) // => ['C', 'Dm', ...]",
        "lineNumber": 9
      },
      {
        "title": "kind",
        "kind": "function"
      },
      {
        "title": "memberof",
        "description": "module"
      },
      {
        "title": "static"
      }
    ],
    "loc": {
      "start": {
        "line": 7,
        "column": 0
      },
      "end": {
        "line": 18,
        "column": 3
      }
    },
    "context": {
      "loc": {
        "start": {
          "line": 19,
          "column": 0
        },
        "end": {
          "line": 24,
          "column": 0
        }
      },
      "file": "./packages/scale-triads/chords.js",
      "code": "'use strict'\n\nvar scale = require('./scale')\nvar chord = require('music-scale/chord')\nvar modes = require('music-scale/modes')\n\n/**\n * Get chords of a key\n *\n * @name key.chords\n * @function\n * @param {String} name - the key name\n * @return {Array} an array with the key chords\n *\n * @example\n * key.chords('C major') // => ['C', 'Dm', 'Em', 'F', 'G7', 'Am', 'Bo'\n * key.chords('major', false) // => ['C', 'Dm', ...]\n */\nmodule.exports = function (k) {\n  return modes(scale(k)).map(function (s) {\n    return chord(s)\n  })\n}\n"
    },
    "name": "key.chords",
    "params": [
      {
        "title": "param",
        "description": "the key name",
        "lineNumber": 6,
        "type": {
          "type": "NameExpression",
          "name": "String"
        },
        "name": "name"
      }
    ],
    "returns": [
      {
        "title": "returns",
        "description": "an array with the key chords",
        "lineNumber": 7,
        "type": {
          "type": "NameExpression",
          "name": "Array"
        }
      }
    ],
    "examples": [
      "key.chords(<span class=\"hljs-string\">'C major'</span>) <span class=\"hljs-comment\">// =&gt; ['C', 'Dm', 'Em', 'F', 'G7', 'Am', 'Bo'</span>\nkey.chords(<span class=\"hljs-string\">'major'</span>, <span class=\"hljs-literal\">false</span>) <span class=\"hljs-comment\">// =&gt; ['C', 'Dm', ...]</span>"
    ],
    "kind": "function",
    "memberof": "module",
    "scope": "static",
    "members": {
      "instance": [],
      "static": []
    },
    "events": [],
    "path": [
      "key.chords"
    ]
  },
  {
    "description": "Parse a key name",
    "tags": [
      {
        "title": "name",
        "description": null,
        "lineNumber": 3,
        "name": "key.parse"
      },
      {
        "title": "function",
        "description": null,
        "lineNumber": 4,
        "name": null
      },
      {
        "title": "param",
        "description": "the key name",
        "lineNumber": 6,
        "type": {
          "type": "NameExpression",
          "name": "String"
        },
        "name": "name"
      },
      {
        "title": "returns",
        "description": "an array with the tonic and mode or null if not valid key",
        "lineNumber": 7,
        "type": {
          "type": "NameExpression",
          "name": "Array"
        }
      },
      {
        "title": "example",
        "description": "var key = require('music-key')\nkey.parse('C major') // => ['C', 'major']\nkey.parse('fx MINOR') // => ['F##', 'minor']\nkey.parse('Ab mixolydian') // => ['Ab', 'mixolydian']\nkey.parse('f bebop') // => 'null'",
        "lineNumber": 9
      },
      {
        "title": "kind",
        "kind": "function"
      },
      {
        "title": "memberof",
        "description": "Key"
      },
      {
        "title": "static"
      }
    ],
    "loc": {
      "start": {
        "line": 43,
        "column": 0
      },
      "end": {
        "line": 57,
        "column": 3
      }
    },
    "context": {
      "loc": {
        "start": {
          "line": 58,
          "column": 0
        },
        "end": {
          "line": 74,
          "column": 0
        }
      },
      "file": "./packages/music-key/index.js",
      "code": "'use strict'\n\nvar transpose = require('note-transposer')\nvar interval = require('note-interval')\nvar parse = require('music-notation/note/parse')\nvar parseI = require('music-notation/interval/parse')\nvar str = require('music-notation/note/str')\n\nvar REGEX = /^#{1,7}|b{1,7}$/\nvar KEYS = { major: 1, minor: 6, ionian: 1, dorian: 2, phrygian: 3, lydian: 4,\n  mixolydian: 5, aeolian: 6, locrian: 7 }\nvar SCALES = [\n  '1 2 3 4 5 6 7', '1 2 3b 4 5 6 7b', '1 2b 3b 4 5 6b 7b', '1 2 3 4# 5 6 7',\n  '1 2 3 4 5 6 7b', '1 2 3b 4 5 6b 7b', '1 2b 3b 4 5b 6b 7b'\n].map(function (g) { return g.split(' ') })\n\n/**\n * Create a key from a string. A key is a string with a tonic and a mode\n *\n * @name key\n * @function\n *\n * @example\n * var key = require('music-key')\n * key('C major') // => 'C major'\n * key('c Major') // => 'C major'\n * key('C') // => 'C major'\n * key('dbb miXolydian') // => 'Dbb mixolydian'\n */\nfunction Key (str) {\n  if (/^-?\\d$/.exec(str)) {\n    return major(+str)\n  } else if (REGEX.exec(str)) {\n    var dir = str[0] === 'b' ? -1 : 1\n    return major(str.length * dir)\n  } else {\n    var p = Key.parse(str)\n    return p ? p.tonic + ' ' + p.mode : null\n  }\n}\nfunction major (n) { return transpose('C', [n, 0]) + ' major' }\n\n/**\n * Parse a key name\n *\n * @name key.parse\n * @function\n * @param {String} name - the key name\n * @return {Array} an array with the tonic and mode or null if not valid key\n *\n * @example\n * var key = require('music-key')\n * key.parse('C major') // => ['C', 'major']\n * key.parse('fx MINOR') // => ['F##', 'minor']\n * key.parse('Ab mixolydian') // => ['Ab', 'mixolydian']\n * key.parse('f bebop') // => 'null'\n */\nKey.parse = function (name) {\n  var m, s, t\n  if (!name) return null\n  s = name.trim().split(/\\s+/)\n  t = str(parse((s[0])))\n  if (s.length === 1) {\n    m = s[0].toLowerCase()\n    if (KEYS[m]) return k(null, m)\n    else if (t) return k(t, 'major')\n    else return null\n  }\n  m = s[1].toLowerCase()\n  if (t && KEYS[m]) return k(t, m)\n  return null\n}\n\nfunction k (t, m) { return {tonic: t || false, mode: m, alt: KEYS[m]} }\n\n/**\n * Get relative of a key\n *\n * This function is currified, so it can be partially applied (see examples)\n *\n * @name key.relative\n * @function\n * @param {String} relative - the name of the relative mode desired\n * @param {String} key - the key name\n * @return {String} the relative key name or null if the key or the relative name\n * are not valid\n *\n * @example\n * var key = require('music-key')\n * key.relative('minor', 'C major') // => 'A minor'\n * key.relative('major', 'A minor') // => 'C major'\n * key.relative('dorian', 'F major') // => 'G dorian'\n *\n * // partially application\n * var minorOf = key.relative('minor')\n * minorOf('Bb major') // => 'G minor'\n */\nKey.relative = function (rel, key) {\n  if (arguments.length === 1) return function (k) { return Key.relative(rel, k) }\n  var k = Key.parse(key)\n  var r = Key.parse(rel)\n  if (!k || !k.tonic || !r) return null\n  var major = k.mode === 'major' ? k.tonic : transpose(k.tonic, '-' + k.alt)\n  return r.mode === 'major' ? major + ' major' : transpose(major, '' + r.alt) + ' ' + rel\n}\n\n/**\n * Get the number of alterations of a key\n *\n * @name key.alteratons\n * @function\n * @param {String} name - the key name\n * @return {Integer} the number of alterations or null if not valid key\n *\n * @example\n * var key = require('music-key')\n * key.alterations('C major') // => 0\n * key.alterations('F major') // => -1\n * key.alterations('Eb major') // => -3\n * key.alterations('A major') // => 3\n * key.alterations('nonsense') // => null\n */\nKey.alterations = function (key) {\n  var k = Key.relative('major', key)\n  return k ? parseI(interval('C', k.split(' ')[0]))[0] : null\n}\n\n/**\n * Get signature of a key\n *\n * @name key.signature\n * @function\n * @param {String} name - the key name\n * @return {String} a string with the alterations\n *\n * @example\n * var key = require('music-key')\n * key.signature('F major') // => 'b'\n * key.signature('Eb major') // => 'bbb'\n * key.signature('A major') // => '###'\n * key.signature('C major') // => ''\n * key.signature('nonsense') // => null\n */\nKey.signature = function (key) {\n  var n = Key.alterations(key)\n  return n !== null ? new Array(Math.abs(n) + 1).join(n < 0 ? 'b' : '#') : null\n}\n\n/**\n * Get a list of altered notes in the appropriate order\n *\n * @name key.altered\n * @function\n * @param {String} name - the key name\n * @return {Array} an array with the altered notes ordered or an empty array\n * if its not a valid key name\n *\n * @example\n * key.altered('F major') // => ['Bb']\n * key.altered('Eb major') // => ['Bb', 'Eb', 'Ab']\n * key.altered('A major') // => ['F#', 'C#', 'G#']\n */\nKey.altered = function (k) {\n  var a = Key.alterations(k)\n  if (a === null) return null\n  var notes = []\n  var tonic = a > 0 ? 'B' : 'F'\n  var interval = a > 0 ? [1, 0] : [-1, 0]\n  var l = Math.abs(a)\n  for (var i = 0; i < l; i++) {\n    tonic = transpose(tonic, interval)\n    notes.push(tonic)\n  }\n  return notes\n}\n\n/**\n * Get the scale of a key\n *\n * @name key.scale\n * @function\n *\n * @example\n * var key = require('music-key')\n * key.scale('C major') // => ['C', 'D', 'E', ...]\n */\nKey.scale = function (name) {\n  var k = Key.parse(name)\n  if (!k) return []\n  return SCALES[k.alt - 1].map(transpose(k.tonic))\n}\n\nmodule.exports = Key\n"
    },
    "name": "key.parse",
    "params": [
      {
        "title": "param",
        "description": "the key name",
        "lineNumber": 6,
        "type": {
          "type": "NameExpression",
          "name": "String"
        },
        "name": "name"
      }
    ],
    "returns": [
      {
        "title": "returns",
        "description": "an array with the tonic and mode or null if not valid key",
        "lineNumber": 7,
        "type": {
          "type": "NameExpression",
          "name": "Array"
        }
      }
    ],
    "examples": [
      "<span class=\"hljs-keyword\">var</span> key = <span class=\"hljs-built_in\">require</span>(<span class=\"hljs-string\">'music-key'</span>)\nkey.parse(<span class=\"hljs-string\">'C major'</span>) <span class=\"hljs-comment\">// =&gt; ['C', 'major']</span>\nkey.parse(<span class=\"hljs-string\">'fx MINOR'</span>) <span class=\"hljs-comment\">// =&gt; ['F##', 'minor']</span>\nkey.parse(<span class=\"hljs-string\">'Ab mixolydian'</span>) <span class=\"hljs-comment\">// =&gt; ['Ab', 'mixolydian']</span>\nkey.parse(<span class=\"hljs-string\">'f bebop'</span>) <span class=\"hljs-comment\">// =&gt; 'null'</span>"
    ],
    "kind": "function",
    "memberof": "Key",
    "scope": "static",
    "members": {
      "instance": [],
      "static": []
    },
    "events": [],
    "path": [
      "key.parse"
    ]
  },
  {
    "description": "Get relative of a key\n\nThis function is currified, so it can be partially applied (see examples)",
    "tags": [
      {
        "title": "name",
        "description": null,
        "lineNumber": 5,
        "name": "key.relative"
      },
      {
        "title": "function",
        "description": null,
        "lineNumber": 6,
        "name": null
      },
      {
        "title": "param",
        "description": "the name of the relative mode desired",
        "lineNumber": 8,
        "type": {
          "type": "NameExpression",
          "name": "String"
        },
        "name": "relative"
      },
      {
        "title": "param",
        "description": "the key name",
        "lineNumber": 9,
        "type": {
          "type": "NameExpression",
          "name": "String"
        },
        "name": "key"
      },
      {
        "title": "returns",
        "description": "the relative key name or null if the key or the relative name\nare not valid",
        "lineNumber": 10,
        "type": {
          "type": "NameExpression",
          "name": "String"
        }
      },
      {
        "title": "example",
        "description": "var key = require('music-key')\nkey.relative('minor', 'C major') // => 'A minor'\nkey.relative('major', 'A minor') // => 'C major'\nkey.relative('dorian', 'F major') // => 'G dorian'\n\n// partially application\nvar minorOf = key.relative('minor')\nminorOf('Bb major') // => 'G minor'",
        "lineNumber": 13
      },
      {
        "title": "kind",
        "kind": "function"
      },
      {
        "title": "memberof",
        "description": "Key"
      },
      {
        "title": "static"
      }
    ],
    "loc": {
      "start": {
        "line": 76,
        "column": 0
      },
      "end": {
        "line": 97,
        "column": 3
      }
    },
    "context": {
      "loc": {
        "start": {
          "line": 98,
          "column": 0
        },
        "end": {
          "line": 123,
          "column": 0
        }
      },
      "file": "./packages/music-key/index.js",
      "code": "'use strict'\n\nvar transpose = require('note-transposer')\nvar interval = require('note-interval')\nvar parse = require('music-notation/note/parse')\nvar parseI = require('music-notation/interval/parse')\nvar str = require('music-notation/note/str')\n\nvar REGEX = /^#{1,7}|b{1,7}$/\nvar KEYS = { major: 1, minor: 6, ionian: 1, dorian: 2, phrygian: 3, lydian: 4,\n  mixolydian: 5, aeolian: 6, locrian: 7 }\nvar SCALES = [\n  '1 2 3 4 5 6 7', '1 2 3b 4 5 6 7b', '1 2b 3b 4 5 6b 7b', '1 2 3 4# 5 6 7',\n  '1 2 3 4 5 6 7b', '1 2 3b 4 5 6b 7b', '1 2b 3b 4 5b 6b 7b'\n].map(function (g) { return g.split(' ') })\n\n/**\n * Create a key from a string. A key is a string with a tonic and a mode\n *\n * @name key\n * @function\n *\n * @example\n * var key = require('music-key')\n * key('C major') // => 'C major'\n * key('c Major') // => 'C major'\n * key('C') // => 'C major'\n * key('dbb miXolydian') // => 'Dbb mixolydian'\n */\nfunction Key (str) {\n  if (/^-?\\d$/.exec(str)) {\n    return major(+str)\n  } else if (REGEX.exec(str)) {\n    var dir = str[0] === 'b' ? -1 : 1\n    return major(str.length * dir)\n  } else {\n    var p = Key.parse(str)\n    return p ? p.tonic + ' ' + p.mode : null\n  }\n}\nfunction major (n) { return transpose('C', [n, 0]) + ' major' }\n\n/**\n * Parse a key name\n *\n * @name key.parse\n * @function\n * @param {String} name - the key name\n * @return {Array} an array with the tonic and mode or null if not valid key\n *\n * @example\n * var key = require('music-key')\n * key.parse('C major') // => ['C', 'major']\n * key.parse('fx MINOR') // => ['F##', 'minor']\n * key.parse('Ab mixolydian') // => ['Ab', 'mixolydian']\n * key.parse('f bebop') // => 'null'\n */\nKey.parse = function (name) {\n  var m, s, t\n  if (!name) return null\n  s = name.trim().split(/\\s+/)\n  t = str(parse((s[0])))\n  if (s.length === 1) {\n    m = s[0].toLowerCase()\n    if (KEYS[m]) return k(null, m)\n    else if (t) return k(t, 'major')\n    else return null\n  }\n  m = s[1].toLowerCase()\n  if (t && KEYS[m]) return k(t, m)\n  return null\n}\n\nfunction k (t, m) { return {tonic: t || false, mode: m, alt: KEYS[m]} }\n\n/**\n * Get relative of a key\n *\n * This function is currified, so it can be partially applied (see examples)\n *\n * @name key.relative\n * @function\n * @param {String} relative - the name of the relative mode desired\n * @param {String} key - the key name\n * @return {String} the relative key name or null if the key or the relative name\n * are not valid\n *\n * @example\n * var key = require('music-key')\n * key.relative('minor', 'C major') // => 'A minor'\n * key.relative('major', 'A minor') // => 'C major'\n * key.relative('dorian', 'F major') // => 'G dorian'\n *\n * // partially application\n * var minorOf = key.relative('minor')\n * minorOf('Bb major') // => 'G minor'\n */\nKey.relative = function (rel, key) {\n  if (arguments.length === 1) return function (k) { return Key.relative(rel, k) }\n  var k = Key.parse(key)\n  var r = Key.parse(rel)\n  if (!k || !k.tonic || !r) return null\n  var major = k.mode === 'major' ? k.tonic : transpose(k.tonic, '-' + k.alt)\n  return r.mode === 'major' ? major + ' major' : transpose(major, '' + r.alt) + ' ' + rel\n}\n\n/**\n * Get the number of alterations of a key\n *\n * @name key.alteratons\n * @function\n * @param {String} name - the key name\n * @return {Integer} the number of alterations or null if not valid key\n *\n * @example\n * var key = require('music-key')\n * key.alterations('C major') // => 0\n * key.alterations('F major') // => -1\n * key.alterations('Eb major') // => -3\n * key.alterations('A major') // => 3\n * key.alterations('nonsense') // => null\n */\nKey.alterations = function (key) {\n  var k = Key.relative('major', key)\n  return k ? parseI(interval('C', k.split(' ')[0]))[0] : null\n}\n\n/**\n * Get signature of a key\n *\n * @name key.signature\n * @function\n * @param {String} name - the key name\n * @return {String} a string with the alterations\n *\n * @example\n * var key = require('music-key')\n * key.signature('F major') // => 'b'\n * key.signature('Eb major') // => 'bbb'\n * key.signature('A major') // => '###'\n * key.signature('C major') // => ''\n * key.signature('nonsense') // => null\n */\nKey.signature = function (key) {\n  var n = Key.alterations(key)\n  return n !== null ? new Array(Math.abs(n) + 1).join(n < 0 ? 'b' : '#') : null\n}\n\n/**\n * Get a list of altered notes in the appropriate order\n *\n * @name key.altered\n * @function\n * @param {String} name - the key name\n * @return {Array} an array with the altered notes ordered or an empty array\n * if its not a valid key name\n *\n * @example\n * key.altered('F major') // => ['Bb']\n * key.altered('Eb major') // => ['Bb', 'Eb', 'Ab']\n * key.altered('A major') // => ['F#', 'C#', 'G#']\n */\nKey.altered = function (k) {\n  var a = Key.alterations(k)\n  if (a === null) return null\n  var notes = []\n  var tonic = a > 0 ? 'B' : 'F'\n  var interval = a > 0 ? [1, 0] : [-1, 0]\n  var l = Math.abs(a)\n  for (var i = 0; i < l; i++) {\n    tonic = transpose(tonic, interval)\n    notes.push(tonic)\n  }\n  return notes\n}\n\n/**\n * Get the scale of a key\n *\n * @name key.scale\n * @function\n *\n * @example\n * var key = require('music-key')\n * key.scale('C major') // => ['C', 'D', 'E', ...]\n */\nKey.scale = function (name) {\n  var k = Key.parse(name)\n  if (!k) return []\n  return SCALES[k.alt - 1].map(transpose(k.tonic))\n}\n\nmodule.exports = Key\n"
    },
    "name": "key.relative",
    "params": [
      {
        "title": "param",
        "description": "the name of the relative mode desired",
        "lineNumber": 8,
        "type": {
          "type": "NameExpression",
          "name": "String"
        },
        "name": "relative"
      },
      {
        "title": "param",
        "description": "the key name",
        "lineNumber": 9,
        "type": {
          "type": "NameExpression",
          "name": "String"
        },
        "name": "key"
      }
    ],
    "returns": [
      {
        "title": "returns",
        "description": "the relative key name or null if the key or the relative name\nare not valid",
        "lineNumber": 10,
        "type": {
          "type": "NameExpression",
          "name": "String"
        }
      }
    ],
    "examples": [
      "<span class=\"hljs-keyword\">var</span> key = <span class=\"hljs-built_in\">require</span>(<span class=\"hljs-string\">'music-key'</span>)\nkey.relative(<span class=\"hljs-string\">'minor'</span>, <span class=\"hljs-string\">'C major'</span>) <span class=\"hljs-comment\">// =&gt; 'A minor'</span>\nkey.relative(<span class=\"hljs-string\">'major'</span>, <span class=\"hljs-string\">'A minor'</span>) <span class=\"hljs-comment\">// =&gt; 'C major'</span>\nkey.relative(<span class=\"hljs-string\">'dorian'</span>, <span class=\"hljs-string\">'F major'</span>) <span class=\"hljs-comment\">// =&gt; 'G dorian'</span>\n\n<span class=\"hljs-comment\">// partially application</span>\n<span class=\"hljs-keyword\">var</span> minorOf = key.relative(<span class=\"hljs-string\">'minor'</span>)\nminorOf(<span class=\"hljs-string\">'Bb major'</span>) <span class=\"hljs-comment\">// =&gt; 'G minor'</span>"
    ],
    "kind": "function",
    "memberof": "Key",
    "scope": "static",
    "members": {
      "instance": [],
      "static": []
    },
    "events": [],
    "path": [
      "key.relative"
    ]
  },
  {
    "description": "Get the scale of a key",
    "tags": [
      {
        "title": "name",
        "description": null,
        "lineNumber": 3,
        "name": "key.scale"
      },
      {
        "title": "function",
        "description": null,
        "lineNumber": 4,
        "name": null
      },
      {
        "title": "example",
        "description": "var key = require('music-key')\nkey.scale('C major') // => ['C', 'D', 'E', ...]",
        "lineNumber": 8
      },
      {
        "title": "kind",
        "kind": "function"
      },
      {
        "title": "memberof",
        "description": "Key"
      },
      {
        "title": "static"
      }
    ],
    "loc": {
      "start": {
        "line": 177,
        "column": 0
      },
      "end": {
        "line": 186,
        "column": 3
      }
    },
    "context": {
      "loc": {
        "start": {
          "line": 187,
          "column": 0
        },
        "end": {
          "line": 193,
          "column": 0
        }
      },
      "file": "./packages/music-key/index.js",
      "code": "'use strict'\n\nvar transpose = require('note-transposer')\nvar interval = require('note-interval')\nvar parse = require('music-notation/note/parse')\nvar parseI = require('music-notation/interval/parse')\nvar str = require('music-notation/note/str')\n\nvar REGEX = /^#{1,7}|b{1,7}$/\nvar KEYS = { major: 1, minor: 6, ionian: 1, dorian: 2, phrygian: 3, lydian: 4,\n  mixolydian: 5, aeolian: 6, locrian: 7 }\nvar SCALES = [\n  '1 2 3 4 5 6 7', '1 2 3b 4 5 6 7b', '1 2b 3b 4 5 6b 7b', '1 2 3 4# 5 6 7',\n  '1 2 3 4 5 6 7b', '1 2 3b 4 5 6b 7b', '1 2b 3b 4 5b 6b 7b'\n].map(function (g) { return g.split(' ') })\n\n/**\n * Create a key from a string. A key is a string with a tonic and a mode\n *\n * @name key\n * @function\n *\n * @example\n * var key = require('music-key')\n * key('C major') // => 'C major'\n * key('c Major') // => 'C major'\n * key('C') // => 'C major'\n * key('dbb miXolydian') // => 'Dbb mixolydian'\n */\nfunction Key (str) {\n  if (/^-?\\d$/.exec(str)) {\n    return major(+str)\n  } else if (REGEX.exec(str)) {\n    var dir = str[0] === 'b' ? -1 : 1\n    return major(str.length * dir)\n  } else {\n    var p = Key.parse(str)\n    return p ? p.tonic + ' ' + p.mode : null\n  }\n}\nfunction major (n) { return transpose('C', [n, 0]) + ' major' }\n\n/**\n * Parse a key name\n *\n * @name key.parse\n * @function\n * @param {String} name - the key name\n * @return {Array} an array with the tonic and mode or null if not valid key\n *\n * @example\n * var key = require('music-key')\n * key.parse('C major') // => ['C', 'major']\n * key.parse('fx MINOR') // => ['F##', 'minor']\n * key.parse('Ab mixolydian') // => ['Ab', 'mixolydian']\n * key.parse('f bebop') // => 'null'\n */\nKey.parse = function (name) {\n  var m, s, t\n  if (!name) return null\n  s = name.trim().split(/\\s+/)\n  t = str(parse((s[0])))\n  if (s.length === 1) {\n    m = s[0].toLowerCase()\n    if (KEYS[m]) return k(null, m)\n    else if (t) return k(t, 'major')\n    else return null\n  }\n  m = s[1].toLowerCase()\n  if (t && KEYS[m]) return k(t, m)\n  return null\n}\n\nfunction k (t, m) { return {tonic: t || false, mode: m, alt: KEYS[m]} }\n\n/**\n * Get relative of a key\n *\n * This function is currified, so it can be partially applied (see examples)\n *\n * @name key.relative\n * @function\n * @param {String} relative - the name of the relative mode desired\n * @param {String} key - the key name\n * @return {String} the relative key name or null if the key or the relative name\n * are not valid\n *\n * @example\n * var key = require('music-key')\n * key.relative('minor', 'C major') // => 'A minor'\n * key.relative('major', 'A minor') // => 'C major'\n * key.relative('dorian', 'F major') // => 'G dorian'\n *\n * // partially application\n * var minorOf = key.relative('minor')\n * minorOf('Bb major') // => 'G minor'\n */\nKey.relative = function (rel, key) {\n  if (arguments.length === 1) return function (k) { return Key.relative(rel, k) }\n  var k = Key.parse(key)\n  var r = Key.parse(rel)\n  if (!k || !k.tonic || !r) return null\n  var major = k.mode === 'major' ? k.tonic : transpose(k.tonic, '-' + k.alt)\n  return r.mode === 'major' ? major + ' major' : transpose(major, '' + r.alt) + ' ' + rel\n}\n\n/**\n * Get the number of alterations of a key\n *\n * @name key.alteratons\n * @function\n * @param {String} name - the key name\n * @return {Integer} the number of alterations or null if not valid key\n *\n * @example\n * var key = require('music-key')\n * key.alterations('C major') // => 0\n * key.alterations('F major') // => -1\n * key.alterations('Eb major') // => -3\n * key.alterations('A major') // => 3\n * key.alterations('nonsense') // => null\n */\nKey.alterations = function (key) {\n  var k = Key.relative('major', key)\n  return k ? parseI(interval('C', k.split(' ')[0]))[0] : null\n}\n\n/**\n * Get signature of a key\n *\n * @name key.signature\n * @function\n * @param {String} name - the key name\n * @return {String} a string with the alterations\n *\n * @example\n * var key = require('music-key')\n * key.signature('F major') // => 'b'\n * key.signature('Eb major') // => 'bbb'\n * key.signature('A major') // => '###'\n * key.signature('C major') // => ''\n * key.signature('nonsense') // => null\n */\nKey.signature = function (key) {\n  var n = Key.alterations(key)\n  return n !== null ? new Array(Math.abs(n) + 1).join(n < 0 ? 'b' : '#') : null\n}\n\n/**\n * Get a list of altered notes in the appropriate order\n *\n * @name key.altered\n * @function\n * @param {String} name - the key name\n * @return {Array} an array with the altered notes ordered or an empty array\n * if its not a valid key name\n *\n * @example\n * key.altered('F major') // => ['Bb']\n * key.altered('Eb major') // => ['Bb', 'Eb', 'Ab']\n * key.altered('A major') // => ['F#', 'C#', 'G#']\n */\nKey.altered = function (k) {\n  var a = Key.alterations(k)\n  if (a === null) return null\n  var notes = []\n  var tonic = a > 0 ? 'B' : 'F'\n  var interval = a > 0 ? [1, 0] : [-1, 0]\n  var l = Math.abs(a)\n  for (var i = 0; i < l; i++) {\n    tonic = transpose(tonic, interval)\n    notes.push(tonic)\n  }\n  return notes\n}\n\n/**\n * Get the scale of a key\n *\n * @name key.scale\n * @function\n *\n * @example\n * var key = require('music-key')\n * key.scale('C major') // => ['C', 'D', 'E', ...]\n */\nKey.scale = function (name) {\n  var k = Key.parse(name)\n  if (!k) return []\n  return SCALES[k.alt - 1].map(transpose(k.tonic))\n}\n\nmodule.exports = Key\n"
    },
    "name": "key.scale",
    "examples": [
      "<span class=\"hljs-keyword\">var</span> key = <span class=\"hljs-built_in\">require</span>(<span class=\"hljs-string\">'music-key'</span>)\nkey.scale(<span class=\"hljs-string\">'C major'</span>) <span class=\"hljs-comment\">// =&gt; ['C', 'D', 'E', ...]</span>"
    ],
    "kind": "function",
    "memberof": "Key",
    "scope": "static",
    "members": {
      "instance": [],
      "static": []
    },
    "events": [],
    "path": [
      "key.scale"
    ]
  },
  {
    "description": "Get signature of a key",
    "tags": [
      {
        "title": "name",
        "description": null,
        "lineNumber": 3,
        "name": "key.signature"
      },
      {
        "title": "function",
        "description": null,
        "lineNumber": 4,
        "name": null
      },
      {
        "title": "param",
        "description": "the key name",
        "lineNumber": 6,
        "type": {
          "type": "NameExpression",
          "name": "String"
        },
        "name": "name"
      },
      {
        "title": "returns",
        "description": "a string with the alterations",
        "lineNumber": 7,
        "type": {
          "type": "NameExpression",
          "name": "String"
        }
      },
      {
        "title": "example",
        "description": "var key = require('music-key')\nkey.signature('F major') // => 'b'\nkey.signature('Eb major') // => 'bbb'\nkey.signature('A major') // => '###'\nkey.signature('C major') // => ''\nkey.signature('nonsense') // => null",
        "lineNumber": 9
      },
      {
        "title": "kind",
        "kind": "function"
      },
      {
        "title": "memberof",
        "description": "Key"
      },
      {
        "title": "static"
      }
    ],
    "loc": {
      "start": {
        "line": 128,
        "column": 0
      },
      "end": {
        "line": 143,
        "column": 3
      }
    },
    "context": {
      "loc": {
        "start": {
          "line": 144,
          "column": 0
        },
        "end": {
          "line": 163,
          "column": 0
        }
      },
      "file": "./packages/music-key/index.js",
      "code": "'use strict'\n\nvar transpose = require('note-transposer')\nvar interval = require('note-interval')\nvar parse = require('music-notation/note/parse')\nvar parseI = require('music-notation/interval/parse')\nvar str = require('music-notation/note/str')\n\nvar REGEX = /^#{1,7}|b{1,7}$/\nvar KEYS = { major: 1, minor: 6, ionian: 1, dorian: 2, phrygian: 3, lydian: 4,\n  mixolydian: 5, aeolian: 6, locrian: 7 }\nvar SCALES = [\n  '1 2 3 4 5 6 7', '1 2 3b 4 5 6 7b', '1 2b 3b 4 5 6b 7b', '1 2 3 4# 5 6 7',\n  '1 2 3 4 5 6 7b', '1 2 3b 4 5 6b 7b', '1 2b 3b 4 5b 6b 7b'\n].map(function (g) { return g.split(' ') })\n\n/**\n * Create a key from a string. A key is a string with a tonic and a mode\n *\n * @name key\n * @function\n *\n * @example\n * var key = require('music-key')\n * key('C major') // => 'C major'\n * key('c Major') // => 'C major'\n * key('C') // => 'C major'\n * key('dbb miXolydian') // => 'Dbb mixolydian'\n */\nfunction Key (str) {\n  if (/^-?\\d$/.exec(str)) {\n    return major(+str)\n  } else if (REGEX.exec(str)) {\n    var dir = str[0] === 'b' ? -1 : 1\n    return major(str.length * dir)\n  } else {\n    var p = Key.parse(str)\n    return p ? p.tonic + ' ' + p.mode : null\n  }\n}\nfunction major (n) { return transpose('C', [n, 0]) + ' major' }\n\n/**\n * Parse a key name\n *\n * @name key.parse\n * @function\n * @param {String} name - the key name\n * @return {Array} an array with the tonic and mode or null if not valid key\n *\n * @example\n * var key = require('music-key')\n * key.parse('C major') // => ['C', 'major']\n * key.parse('fx MINOR') // => ['F##', 'minor']\n * key.parse('Ab mixolydian') // => ['Ab', 'mixolydian']\n * key.parse('f bebop') // => 'null'\n */\nKey.parse = function (name) {\n  var m, s, t\n  if (!name) return null\n  s = name.trim().split(/\\s+/)\n  t = str(parse((s[0])))\n  if (s.length === 1) {\n    m = s[0].toLowerCase()\n    if (KEYS[m]) return k(null, m)\n    else if (t) return k(t, 'major')\n    else return null\n  }\n  m = s[1].toLowerCase()\n  if (t && KEYS[m]) return k(t, m)\n  return null\n}\n\nfunction k (t, m) { return {tonic: t || false, mode: m, alt: KEYS[m]} }\n\n/**\n * Get relative of a key\n *\n * This function is currified, so it can be partially applied (see examples)\n *\n * @name key.relative\n * @function\n * @param {String} relative - the name of the relative mode desired\n * @param {String} key - the key name\n * @return {String} the relative key name or null if the key or the relative name\n * are not valid\n *\n * @example\n * var key = require('music-key')\n * key.relative('minor', 'C major') // => 'A minor'\n * key.relative('major', 'A minor') // => 'C major'\n * key.relative('dorian', 'F major') // => 'G dorian'\n *\n * // partially application\n * var minorOf = key.relative('minor')\n * minorOf('Bb major') // => 'G minor'\n */\nKey.relative = function (rel, key) {\n  if (arguments.length === 1) return function (k) { return Key.relative(rel, k) }\n  var k = Key.parse(key)\n  var r = Key.parse(rel)\n  if (!k || !k.tonic || !r) return null\n  var major = k.mode === 'major' ? k.tonic : transpose(k.tonic, '-' + k.alt)\n  return r.mode === 'major' ? major + ' major' : transpose(major, '' + r.alt) + ' ' + rel\n}\n\n/**\n * Get the number of alterations of a key\n *\n * @name key.alteratons\n * @function\n * @param {String} name - the key name\n * @return {Integer} the number of alterations or null if not valid key\n *\n * @example\n * var key = require('music-key')\n * key.alterations('C major') // => 0\n * key.alterations('F major') // => -1\n * key.alterations('Eb major') // => -3\n * key.alterations('A major') // => 3\n * key.alterations('nonsense') // => null\n */\nKey.alterations = function (key) {\n  var k = Key.relative('major', key)\n  return k ? parseI(interval('C', k.split(' ')[0]))[0] : null\n}\n\n/**\n * Get signature of a key\n *\n * @name key.signature\n * @function\n * @param {String} name - the key name\n * @return {String} a string with the alterations\n *\n * @example\n * var key = require('music-key')\n * key.signature('F major') // => 'b'\n * key.signature('Eb major') // => 'bbb'\n * key.signature('A major') // => '###'\n * key.signature('C major') // => ''\n * key.signature('nonsense') // => null\n */\nKey.signature = function (key) {\n  var n = Key.alterations(key)\n  return n !== null ? new Array(Math.abs(n) + 1).join(n < 0 ? 'b' : '#') : null\n}\n\n/**\n * Get a list of altered notes in the appropriate order\n *\n * @name key.altered\n * @function\n * @param {String} name - the key name\n * @return {Array} an array with the altered notes ordered or an empty array\n * if its not a valid key name\n *\n * @example\n * key.altered('F major') // => ['Bb']\n * key.altered('Eb major') // => ['Bb', 'Eb', 'Ab']\n * key.altered('A major') // => ['F#', 'C#', 'G#']\n */\nKey.altered = function (k) {\n  var a = Key.alterations(k)\n  if (a === null) return null\n  var notes = []\n  var tonic = a > 0 ? 'B' : 'F'\n  var interval = a > 0 ? [1, 0] : [-1, 0]\n  var l = Math.abs(a)\n  for (var i = 0; i < l; i++) {\n    tonic = transpose(tonic, interval)\n    notes.push(tonic)\n  }\n  return notes\n}\n\n/**\n * Get the scale of a key\n *\n * @name key.scale\n * @function\n *\n * @example\n * var key = require('music-key')\n * key.scale('C major') // => ['C', 'D', 'E', ...]\n */\nKey.scale = function (name) {\n  var k = Key.parse(name)\n  if (!k) return []\n  return SCALES[k.alt - 1].map(transpose(k.tonic))\n}\n\nmodule.exports = Key\n"
    },
    "name": "key.signature",
    "params": [
      {
        "title": "param",
        "description": "the key name",
        "lineNumber": 6,
        "type": {
          "type": "NameExpression",
          "name": "String"
        },
        "name": "name"
      }
    ],
    "returns": [
      {
        "title": "returns",
        "description": "a string with the alterations",
        "lineNumber": 7,
        "type": {
          "type": "NameExpression",
          "name": "String"
        }
      }
    ],
    "examples": [
      "<span class=\"hljs-keyword\">var</span> key = <span class=\"hljs-built_in\">require</span>(<span class=\"hljs-string\">'music-key'</span>)\nkey.signature(<span class=\"hljs-string\">'F major'</span>) <span class=\"hljs-comment\">// =&gt; 'b'</span>\nkey.signature(<span class=\"hljs-string\">'Eb major'</span>) <span class=\"hljs-comment\">// =&gt; 'bbb'</span>\nkey.signature(<span class=\"hljs-string\">'A major'</span>) <span class=\"hljs-comment\">// =&gt; '###'</span>\nkey.signature(<span class=\"hljs-string\">'C major'</span>) <span class=\"hljs-comment\">// =&gt; ''</span>\nkey.signature(<span class=\"hljs-string\">'nonsense'</span>) <span class=\"hljs-comment\">// =&gt; null</span>"
    ],
    "kind": "function",
    "memberof": "Key",
    "scope": "static",
    "members": {
      "instance": [],
      "static": []
    },
    "events": [],
    "path": [
      "key.signature"
    ]
  },
  {
    "description": "Get the midi number of a note\n\nIf the argument passed to this function is a valid midi number, it returns it\n\nThe note can be an string in scientific notation or\n[array pitch notation](https://github.com/danigb/music.array.notation)",
    "tags": [
      {
        "title": "name",
        "description": null,
        "lineNumber": 8,
        "name": "midi"
      },
      {
        "title": "function",
        "description": null,
        "lineNumber": 9,
        "name": null
      },
      {
        "title": "param",
        "description": "the note in string or array notation.\nIf the parameter is a valid midi number it return it as it.",
        "lineNumber": 11,
        "type": {
          "type": "UnionType",
          "elements": [
            {
              "type": "NameExpression",
              "name": "String"
            },
            {
              "type": "NameExpression",
              "name": "Array"
            },
            {
              "type": "NameExpression",
              "name": "Integer"
            }
          ]
        },
        "name": "note"
      },
      {
        "title": "returns",
        "description": "the midi number",
        "lineNumber": 13,
        "type": {
          "type": "NameExpression",
          "name": "Integer"
        }
      },
      {
        "title": "example",
        "description": "var midi = require('note-midi')\nmidi('A4') // => 69\nmidi('a3') // => 57\nmidi([0, 2]) // => 36 (C2 in array notation)\nmidi(60) // => 60\nmidi('C') // => null (pitch classes don't have midi number)",
        "lineNumber": 15
      },
      {
        "title": "kind",
        "kind": "function"
      }
    ],
    "loc": {
      "start": {
        "line": 5,
        "column": 0
      },
      "end": {
        "line": 26,
        "column": 3
      }
    },
    "context": {
      "loc": {
        "start": {
          "line": 27,
          "column": 0
        },
        "end": {
          "line": 33,
          "column": 1
        }
      },
      "file": "./packages/note-midi/index.js",
      "code": "'use strict'\n\nvar parse = require('music-notation/note/parse')\n\n/**\n * Get the midi number of a note\n *\n * If the argument passed to this function is a valid midi number, it returns it\n *\n * The note can be an string in scientific notation or\n * [array pitch notation](https://github.com/danigb/music.array.notation)\n *\n * @name midi\n * @function\n * @param {String|Array|Integer} note - the note in string or array notation.\n * If the parameter is a valid midi number it return it as it.\n * @return {Integer} the midi number\n *\n * @example\n * var midi = require('note-midi')\n * midi('A4') // => 69\n * midi('a3') // => 57\n * midi([0, 2]) // => 36 (C2 in array notation)\n * midi(60) // => 60\n * midi('C') // => null (pitch classes don't have midi number)\n */\nfunction midi (note) {\n  if ((typeof note === 'number' || typeof note === 'string') &&\n    note > 0 && note < 128) return +note\n  var p = Array.isArray(note) ? note : parse(note)\n  if (!p || p.length < 2) return null\n  return p[0] * 7 + p[1] * 12 + 12\n}\n\nif (typeof module === 'object' && module.exports) module.exports = midi\nif (typeof window !== 'undefined') window.midi = midi\n"
    },
    "name": "midi",
    "params": [
      {
        "title": "param",
        "description": "the note in string or array notation.\nIf the parameter is a valid midi number it return it as it.",
        "lineNumber": 11,
        "type": {
          "type": "UnionType",
          "elements": [
            {
              "type": "NameExpression",
              "name": "String"
            },
            {
              "type": "NameExpression",
              "name": "Array"
            },
            {
              "type": "NameExpression",
              "name": "Integer"
            }
          ]
        },
        "name": "note"
      }
    ],
    "returns": [
      {
        "title": "returns",
        "description": "the midi number",
        "lineNumber": 13,
        "type": {
          "type": "NameExpression",
          "name": "Integer"
        }
      }
    ],
    "examples": [
      "<span class=\"hljs-keyword\">var</span> midi = <span class=\"hljs-built_in\">require</span>(<span class=\"hljs-string\">'note-midi'</span>)\nmidi(<span class=\"hljs-string\">'A4'</span>) <span class=\"hljs-comment\">// =&gt; 69</span>\nmidi(<span class=\"hljs-string\">'a3'</span>) <span class=\"hljs-comment\">// =&gt; 57</span>\nmidi([<span class=\"hljs-number\">0</span>, <span class=\"hljs-number\">2</span>]) <span class=\"hljs-comment\">// =&gt; 36 (C2 in array notation)</span>\nmidi(<span class=\"hljs-number\">60</span>) <span class=\"hljs-comment\">// =&gt; 60</span>\nmidi(<span class=\"hljs-string\">'C'</span>) <span class=\"hljs-comment\">// =&gt; null (pitch classes don't have midi number)</span>"
    ],
    "kind": "function",
    "members": {
      "instance": [],
      "static": []
    },
    "events": [],
    "path": [
      "midi"
    ]
  },
  {
    "description": "Get the pitch frequency in herzs (with custom concert tuning) from a midi number\n\nThis function is currified so it can be partially applied (see examples)",
    "tags": [
      {
        "title": "name",
        "description": null,
        "lineNumber": 5,
        "name": "midi.freq"
      },
      {
        "title": "function",
        "description": null,
        "lineNumber": 6,
        "name": null
      },
      {
        "title": "param",
        "description": "the frequency of A4 (null means 440)",
        "lineNumber": 8,
        "type": {
          "type": "NameExpression",
          "name": "Float"
        },
        "name": "tuning"
      },
      {
        "title": "param",
        "description": "the midi number",
        "lineNumber": 9,
        "type": {
          "type": "NameExpression",
          "name": "Integer"
        },
        "name": "midi"
      },
      {
        "title": "returns",
        "description": "the frequency of the note",
        "lineNumber": 10,
        "type": {
          "type": "NameExpression",
          "name": "Float"
        }
      },
      {
        "title": "example",
        "description": "var freq = require('midi-freq')\n// 69 midi is A4\nfreq(null, 69) // => 440\nfreq(444, 69) // => 444",
        "lineNumber": 12
      },
      {
        "title": "example",
        "description": "// partially applied\nvar freq = require('midi-freq')(440)\nfreq(69) // => 440",
        "lineNumber": 18
      },
      {
        "title": "kind",
        "kind": "function"
      },
      {
        "title": "memberof",
        "description": "module"
      },
      {
        "title": "static"
      }
    ],
    "loc": {
      "start": {
        "line": 1,
        "column": 0
      },
      "end": {
        "line": 22,
        "column": 3
      }
    },
    "context": {
      "loc": {
        "start": {
          "line": 23,
          "column": 0
        },
        "end": {
          "line": 31,
          "column": 0
        }
      },
      "file": "./packages/midi-freq/index.js",
      "code": "module.exports = function freq (tuning, midi) {\n  tuning = tuning || 440\n  if (arguments.length > 1) return freq(tuning)(midi)\n\n  return function (m) {\n    return m > 0 && m < 128 ? Math.pow(2, (m - 69) / 12) * tuning : null\n  }\n}\n"
    },
    "name": "midi.freq",
    "params": [
      {
        "title": "param",
        "description": "the frequency of A4 (null means 440)",
        "lineNumber": 8,
        "type": {
          "type": "NameExpression",
          "name": "Float"
        },
        "name": "tuning"
      },
      {
        "title": "param",
        "description": "the midi number",
        "lineNumber": 9,
        "type": {
          "type": "NameExpression",
          "name": "Integer"
        },
        "name": "midi"
      }
    ],
    "returns": [
      {
        "title": "returns",
        "description": "the frequency of the note",
        "lineNumber": 10,
        "type": {
          "type": "NameExpression",
          "name": "Float"
        }
      }
    ],
    "examples": [
      "<span class=\"hljs-keyword\">var</span> freq = <span class=\"hljs-built_in\">require</span>(<span class=\"hljs-string\">'midi-freq'</span>)\n<span class=\"hljs-comment\">// 69 midi is A4</span>\nfreq(<span class=\"hljs-literal\">null</span>, <span class=\"hljs-number\">69</span>) <span class=\"hljs-comment\">// =&gt; 440</span>\nfreq(<span class=\"hljs-number\">444</span>, <span class=\"hljs-number\">69</span>) <span class=\"hljs-comment\">// =&gt; 444</span>",
      "<span class=\"hljs-comment\">// partially applied</span>\n<span class=\"hljs-keyword\">var</span> freq = <span class=\"hljs-built_in\">require</span>(<span class=\"hljs-string\">'midi-freq'</span>)(<span class=\"hljs-number\">440</span>)\nfreq(<span class=\"hljs-number\">69</span>) <span class=\"hljs-comment\">// =&gt; 440</span>"
    ],
    "kind": "function",
    "memberof": "module",
    "scope": "static",
    "members": {
      "instance": [],
      "static": []
    },
    "events": [],
    "path": [
      "midi.freq"
    ]
  },
  {
    "description": "Get the note name (in scientific notation) of the given midi number\n\nIt uses MIDI's [Tuning Standard](https://en.wikipedia.org/wiki/MIDI_Tuning_Standard)\nwhere A4 is 69\n\nThis method doesn't take into account diatonic spelling. Always the same\npitch class is given for the same midi number.",
    "tags": [
      {
        "title": "name",
        "description": null,
        "lineNumber": 9,
        "name": "midi.note"
      },
      {
        "title": "function",
        "description": null,
        "lineNumber": 10,
        "name": null
      },
      {
        "title": "param",
        "description": "the midi number",
        "lineNumber": 12,
        "type": {
          "type": "NameExpression",
          "name": "Integer"
        },
        "name": "midi"
      },
      {
        "title": "returns",
        "description": "the pitch",
        "lineNumber": 13,
        "type": {
          "type": "NameExpression",
          "name": "String"
        }
      },
      {
        "title": "example",
        "description": "var note = require('midi-note')\nnote(69) // => 'A4'",
        "lineNumber": 15
      },
      {
        "title": "kind",
        "kind": "function"
      },
      {
        "title": "memberof",
        "description": "module"
      },
      {
        "title": "static"
      }
    ],
    "loc": {
      "start": {
        "line": 5,
        "column": 0
      },
      "end": {
        "line": 22,
        "column": 3
      }
    },
    "context": {
      "loc": {
        "start": {
          "line": 23,
          "column": 0
        },
        "end": {
          "line": 29,
          "column": 0
        }
      },
      "file": "./packages/midi-note/index.js",
      "code": "'use strict'\n\nvar CHROMATIC = [ 'C', 'Db', 'D', 'Eb', 'E', 'F', 'Gb', 'G', 'Ab', 'A', 'Bb', 'B' ]\n\n/**\n * Get the note name (in scientific notation) of the given midi number\n *\n * It uses MIDI's [Tuning Standard](https://en.wikipedia.org/wiki/MIDI_Tuning_Standard)\n * where A4 is 69\n *\n * This method doesn't take into account diatonic spelling. Always the same\n * pitch class is given for the same midi number.\n *\n * @name midi.note\n * @function\n * @param {Integer} midi - the midi number\n * @return {String} the pitch\n *\n * @example\n * var note = require('midi-note')\n * note(69) // => 'A4'\n */\nmodule.exports = function (midi) {\n  if (isNaN(midi) || midi < 0 || midi > 127) return null\n  var name = CHROMATIC[midi % 12]\n  var oct = Math.floor(midi / 12) - 1\n  return name + oct\n}\n"
    },
    "name": "midi.note",
    "params": [
      {
        "title": "param",
        "description": "the midi number",
        "lineNumber": 12,
        "type": {
          "type": "NameExpression",
          "name": "Integer"
        },
        "name": "midi"
      }
    ],
    "returns": [
      {
        "title": "returns",
        "description": "the pitch",
        "lineNumber": 13,
        "type": {
          "type": "NameExpression",
          "name": "String"
        }
      }
    ],
    "examples": [
      "<span class=\"hljs-keyword\">var</span> note = <span class=\"hljs-built_in\">require</span>(<span class=\"hljs-string\">'midi-note'</span>)\nnote(<span class=\"hljs-number\">69</span>) <span class=\"hljs-comment\">// =&gt; 'A4'</span>"
    ],
    "kind": "function",
    "memberof": "module",
    "scope": "static",
    "members": {
      "instance": [],
      "static": []
    },
    "events": [],
    "path": [
      "midi.note"
    ]
  },
  {
    "description": "Get the enharmonics of a note. It returns an array of three elements: the\nbelow enharmonic, the note, and the upper enharmonic",
    "tags": [
      {
        "title": "name",
        "description": null,
        "lineNumber": 4,
        "name": "note.enharmonics"
      },
      {
        "title": "function",
        "description": null,
        "lineNumber": 5,
        "name": null
      },
      {
        "title": "param",
        "description": "the note to get the enharmonics from",
        "lineNumber": 7,
        "type": {
          "type": "NameExpression",
          "name": "String"
        },
        "name": "note"
      },
      {
        "title": "returns",
        "description": "an array of pitches ordered by distance to the given one",
        "lineNumber": 8,
        "type": {
          "type": "NameExpression",
          "name": "Array"
        }
      },
      {
        "title": "example",
        "description": "enharmonics = require('enharmonics')\nenharmonics('C') // => ['B#', 'C', 'Dbb']\nenharmonics('A') // => ['G##', 'A', 'Bbb']\nenharmonics('C#4') // => ['B##3', 'C#4' 'Db4']\nenharmonics('Db') // => ['C#', 'Db', 'Ebbb'])",
        "lineNumber": 10
      },
      {
        "title": "kind",
        "kind": "function"
      }
    ],
    "loc": {
      "start": {
        "line": 8,
        "column": 0
      },
      "end": {
        "line": 23,
        "column": 3
      }
    },
    "context": {
      "loc": {
        "start": {
          "line": 24,
          "column": 0
        },
        "end": {
          "line": 30,
          "column": 1
        }
      },
      "file": "./packages/enharmonics/index.js",
      "code": "'use strict'\n\nvar transpose = require('note-transposer')\n\nvar ASC = [-12, 7] // dimished second\nvar DESC = [12, -7] // descending dimished second\n\n/**\n * Get the enharmonics of a note. It returns an array of three elements: the\n * below enharmonic, the note, and the upper enharmonic\n *\n * @name note.enharmonics\n * @function\n * @param {String} note - the note to get the enharmonics from\n * @return {Array} an array of pitches ordered by distance to the given one\n *\n * @example\n * enharmonics = require('enharmonics')\n * enharmonics('C') // => ['B#', 'C', 'Dbb']\n * enharmonics('A') // => ['G##', 'A', 'Bbb']\n * enharmonics('C#4') // => ['B##3', 'C#4' 'Db4']\n * enharmonics('Db') // => ['C#', 'Db', 'Ebbb'])\n */\nfunction enharmonics (pitch) {\n  var enharmonics = []\n  enharmonics.push(transpose(DESC, pitch))\n  enharmonics.push(pitch)\n  enharmonics.push(transpose(ASC, pitch))\n  return enharmonics\n}\n\n/**\n * Try to get a simpler enharmonic note name\n *\n * @name enharmonics.simplify\n * @function\n * @param {String} note - the note to simplify\n * @return {String} the simplfiied note (can be the same)\n *\n * @example\n * var enharmonics = require('enharmonics')\n * enharmonics.simplify('B#3') // => 'C4'\n */\nenharmonics.simplify = function (pitch) {\n  return enharmonics(pitch).reduce(function (simple, next) {\n    if (!simple) return next\n    return simple.length > next.length ? next : simple\n  }, null)\n}\n\nmodule.exports = enharmonics\n"
    },
    "name": "note.enharmonics",
    "params": [
      {
        "title": "param",
        "description": "the note to get the enharmonics from",
        "lineNumber": 7,
        "type": {
          "type": "NameExpression",
          "name": "String"
        },
        "name": "note"
      }
    ],
    "returns": [
      {
        "title": "returns",
        "description": "an array of pitches ordered by distance to the given one",
        "lineNumber": 8,
        "type": {
          "type": "NameExpression",
          "name": "Array"
        }
      }
    ],
    "examples": [
      "enharmonics = <span class=\"hljs-built_in\">require</span>(<span class=\"hljs-string\">'enharmonics'</span>)\nenharmonics(<span class=\"hljs-string\">'C'</span>) <span class=\"hljs-comment\">// =&gt; ['B#', 'C', 'Dbb']</span>\nenharmonics(<span class=\"hljs-string\">'A'</span>) <span class=\"hljs-comment\">// =&gt; ['G##', 'A', 'Bbb']</span>\nenharmonics(<span class=\"hljs-string\">'C#4'</span>) <span class=\"hljs-comment\">// =&gt; ['B##3', 'C#4' 'Db4']</span>\nenharmonics(<span class=\"hljs-string\">'Db'</span>) <span class=\"hljs-comment\">// =&gt; ['C#', 'Db', 'Ebbb'])</span>"
    ],
    "kind": "function",
    "members": {
      "instance": [],
      "static": []
    },
    "events": [],
    "path": [
      "note.enharmonics"
    ]
  },
  {
    "description": "Convert from midi to note number\nAn alias for `midi.note`",
    "tags": [
      {
        "title": "name",
        "description": null,
        "lineNumber": 3,
        "name": "note.fromMidi"
      },
      {
        "title": "function",
        "description": null,
        "lineNumber": 4,
        "name": null
      },
      {
        "title": "kind",
        "kind": "function"
      },
      {
        "title": "memberof",
        "description": "T.midi"
      },
      {
        "title": "static"
      }
    ],
    "loc": {
      "start": {
        "line": 45,
        "column": 0
      },
      "end": {
        "line": 50,
        "column": 3
      }
    },
    "context": {
      "loc": {
        "start": {
          "line": 51,
          "column": 0
        },
        "end": {
          "line": 53,
          "column": 0
        }
      },
      "file": "./packages/tonal/index.js",
      "code": "function T () {}\n\nT.notation = require('music-notation')\nT.note = T.notation.note\nT.interval = T.notation.interval\nT.roman = T.notation.roman\nT.pitch = T.notation.pitch\n\nT.pitchSet = require('pitch-set')\n\n/**\n * Transpose a note by an interval\n * An alias for `transpose`\n *\n * @name note.transpose\n * @function\n */\nT.note.transpose = T.transpose = require('note-transposer')\n\n/**\n * Harmonizes a note by an interval list\n * An alias for `harmonize`\n *\n * @name note.harmonize\n * @function\n */\nT.harmonizer = require('note-harmonizer')\nT.note.harmonize = T.harmonize = T.harmonizer\n\nT.note.interval = require('note-interval')\nT.note.enharmonics = require('enharmonics')\n\n/**\n * Convert from note name to midi number\n * An alias for `midi`\n *\n * @name note.midi\n * @function\n */\nT.midi = T.note.midi = require('note-midi')\n\nT.midi.freq = require('midi-freq')\n\n/**\n * Convert from midi to note number\n * An alias for `midi.note`\n * @name note.fromMidi\n * @function\n */\nT.midi.note = T.note.fromMidi = require('midi-note')\n\nT.gamut = require('music-gamut')\n\nT.dictionary = require('music-dictionary')\nT.scale = require('music-scale')\nT.chord = require('music-chord')\n\nmodule.exports = T\n"
    },
    "name": "note.fromMidi",
    "kind": "function",
    "memberof": "T.midi",
    "scope": "static",
    "members": {
      "instance": [],
      "static": []
    },
    "events": [],
    "path": [
      "note.fromMidi"
    ]
  },
  {
    "description": "Harmonizes a note by an interval list\nAn alias for `harmonize`",
    "tags": [
      {
        "title": "name",
        "description": null,
        "lineNumber": 4,
        "name": "note.harmonize"
      },
      {
        "title": "function",
        "description": null,
        "lineNumber": 5,
        "name": null
      },
      {
        "title": "kind",
        "kind": "function"
      },
      {
        "title": "memberof",
        "description": "T"
      },
      {
        "title": "static"
      }
    ],
    "loc": {
      "start": {
        "line": 21,
        "column": 0
      },
      "end": {
        "line": 27,
        "column": 3
      }
    },
    "context": {
      "loc": {
        "start": {
          "line": 28,
          "column": 0
        },
        "end": {
          "line": 29,
          "column": 0
        }
      },
      "file": "./packages/tonal/index.js",
      "code": "function T () {}\n\nT.notation = require('music-notation')\nT.note = T.notation.note\nT.interval = T.notation.interval\nT.roman = T.notation.roman\nT.pitch = T.notation.pitch\n\nT.pitchSet = require('pitch-set')\n\n/**\n * Transpose a note by an interval\n * An alias for `transpose`\n *\n * @name note.transpose\n * @function\n */\nT.note.transpose = T.transpose = require('note-transposer')\n\n/**\n * Harmonizes a note by an interval list\n * An alias for `harmonize`\n *\n * @name note.harmonize\n * @function\n */\nT.harmonizer = require('note-harmonizer')\nT.note.harmonize = T.harmonize = T.harmonizer\n\nT.note.interval = require('note-interval')\nT.note.enharmonics = require('enharmonics')\n\n/**\n * Convert from note name to midi number\n * An alias for `midi`\n *\n * @name note.midi\n * @function\n */\nT.midi = T.note.midi = require('note-midi')\n\nT.midi.freq = require('midi-freq')\n\n/**\n * Convert from midi to note number\n * An alias for `midi.note`\n * @name note.fromMidi\n * @function\n */\nT.midi.note = T.note.fromMidi = require('midi-note')\n\nT.gamut = require('music-gamut')\n\nT.dictionary = require('music-dictionary')\nT.scale = require('music-scale')\nT.chord = require('music-chord')\n\nmodule.exports = T\n"
    },
    "name": "note.harmonize",
    "kind": "function",
    "memberof": "T",
    "scope": "static",
    "members": {
      "instance": [],
      "static": []
    },
    "events": [],
    "path": [
      "note.harmonize"
    ]
  },
  {
    "description": "Get the interval between two pitches\n\nIf one or both are pitch classes, a simple ascending interval is returned\n\nThis function can be partially applied (see examples)",
    "tags": [
      {
        "title": "name",
        "description": null,
        "lineNumber": 7,
        "name": "note.interval"
      },
      {
        "title": "function",
        "description": null,
        "lineNumber": 8,
        "name": null
      },
      {
        "title": "param",
        "description": "the first note",
        "lineNumber": 10,
        "type": {
          "type": "NameExpression",
          "name": "String"
        },
        "name": "from"
      },
      {
        "title": "param",
        "description": "the second note",
        "lineNumber": 11,
        "type": {
          "type": "NameExpression",
          "name": "String"
        },
        "name": "to"
      },
      {
        "title": "returns",
        "description": "the interval between them",
        "lineNumber": 12,
        "type": {
          "type": "NameExpression",
          "name": "String"
        }
      },
      {
        "title": "example",
        "description": "var interval = require('note-interval')\ninterval('C2', 'D3') // => '9M'\ninterval('D2', 'C2') // => '-2M'\ninterval('D', 'C') // => '7m'",
        "lineNumber": 14
      },
      {
        "title": "example",
        "description": "// partially applied\nvar fromC = interval('C')\nfromC('D') // => '2M'",
        "lineNumber": 20
      },
      {
        "title": "kind",
        "kind": "function"
      },
      {
        "title": "memberof",
        "description": "module"
      },
      {
        "title": "static"
      }
    ],
    "loc": {
      "start": {
        "line": 5,
        "column": 0
      },
      "end": {
        "line": 28,
        "column": 3
      }
    },
    "context": {
      "loc": {
        "start": {
          "line": 29,
          "column": 0
        },
        "end": {
          "line": 37,
          "column": 0
        }
      },
      "file": "./packages/note-interval/index.js",
      "code": "var parse = require('music-notation/pitch/parse')\nvar str = require('music-notation/pitch/str')\nvar notation = require('music-notation/operation')(parse, str)\n\n/**\n * Get the interval between two pitches\n *\n * If one or both are pitch classes, a simple ascending interval is returned\n *\n * This function can be partially applied (see examples)\n *\n * @name note.interval\n * @function\n * @param {String} from - the first note\n * @param {String} to - the second note\n * @return {String} the interval between them\n *\n * @example\n * var interval = require('note-interval')\n * interval('C2', 'D3') // => '9M'\n * interval('D2', 'C2') // => '-2M'\n * interval('D', 'C') // => '7m'\n *\n * @example\n * // partially applied\n * var fromC = interval('C')\n * fromC('D') // => '2M'\n */\nmodule.exports = notation(function (a, b) {\n  if (!Array.isArray(a) || !Array.isArray(b)) return null\n  if (a.length === 1 || b.length === 1) {\n    var base = b[0] - a[0]\n    return [base, -Math.floor(base * 7 / 12)]\n  }\n  return [b[0] - a[0], b[1] - a[1]]\n})\n"
    },
    "name": "note.interval",
    "params": [
      {
        "title": "param",
        "description": "the first note",
        "lineNumber": 10,
        "type": {
          "type": "NameExpression",
          "name": "String"
        },
        "name": "from"
      },
      {
        "title": "param",
        "description": "the second note",
        "lineNumber": 11,
        "type": {
          "type": "NameExpression",
          "name": "String"
        },
        "name": "to"
      }
    ],
    "returns": [
      {
        "title": "returns",
        "description": "the interval between them",
        "lineNumber": 12,
        "type": {
          "type": "NameExpression",
          "name": "String"
        }
      }
    ],
    "examples": [
      "<span class=\"hljs-keyword\">var</span> interval = <span class=\"hljs-built_in\">require</span>(<span class=\"hljs-string\">'note-interval'</span>)\ninterval(<span class=\"hljs-string\">'C2'</span>, <span class=\"hljs-string\">'D3'</span>) <span class=\"hljs-comment\">// =&gt; '9M'</span>\ninterval(<span class=\"hljs-string\">'D2'</span>, <span class=\"hljs-string\">'C2'</span>) <span class=\"hljs-comment\">// =&gt; '-2M'</span>\ninterval(<span class=\"hljs-string\">'D'</span>, <span class=\"hljs-string\">'C'</span>) <span class=\"hljs-comment\">// =&gt; '7m'</span>",
      "<span class=\"hljs-comment\">// partially applied</span>\n<span class=\"hljs-keyword\">var</span> fromC = interval(<span class=\"hljs-string\">'C'</span>)\nfromC(<span class=\"hljs-string\">'D'</span>) <span class=\"hljs-comment\">// =&gt; '2M'</span>"
    ],
    "kind": "function",
    "memberof": "module",
    "scope": "static",
    "members": {
      "instance": [],
      "static": []
    },
    "events": [],
    "path": [
      "note.interval"
    ]
  },
  {
    "description": "Convert from note name to midi number\nAn alias for `midi`",
    "tags": [
      {
        "title": "name",
        "description": null,
        "lineNumber": 4,
        "name": "note.midi"
      },
      {
        "title": "function",
        "description": null,
        "lineNumber": 5,
        "name": null
      },
      {
        "title": "kind",
        "kind": "function"
      },
      {
        "title": "memberof",
        "description": "T"
      },
      {
        "title": "static"
      }
    ],
    "loc": {
      "start": {
        "line": 34,
        "column": 0
      },
      "end": {
        "line": 40,
        "column": 3
      }
    },
    "context": {
      "loc": {
        "start": {
          "line": 41,
          "column": 0
        },
        "end": {
          "line": 43,
          "column": 0
        }
      },
      "file": "./packages/tonal/index.js",
      "code": "function T () {}\n\nT.notation = require('music-notation')\nT.note = T.notation.note\nT.interval = T.notation.interval\nT.roman = T.notation.roman\nT.pitch = T.notation.pitch\n\nT.pitchSet = require('pitch-set')\n\n/**\n * Transpose a note by an interval\n * An alias for `transpose`\n *\n * @name note.transpose\n * @function\n */\nT.note.transpose = T.transpose = require('note-transposer')\n\n/**\n * Harmonizes a note by an interval list\n * An alias for `harmonize`\n *\n * @name note.harmonize\n * @function\n */\nT.harmonizer = require('note-harmonizer')\nT.note.harmonize = T.harmonize = T.harmonizer\n\nT.note.interval = require('note-interval')\nT.note.enharmonics = require('enharmonics')\n\n/**\n * Convert from note name to midi number\n * An alias for `midi`\n *\n * @name note.midi\n * @function\n */\nT.midi = T.note.midi = require('note-midi')\n\nT.midi.freq = require('midi-freq')\n\n/**\n * Convert from midi to note number\n * An alias for `midi.note`\n * @name note.fromMidi\n * @function\n */\nT.midi.note = T.note.fromMidi = require('midi-note')\n\nT.gamut = require('music-gamut')\n\nT.dictionary = require('music-dictionary')\nT.scale = require('music-scale')\nT.chord = require('music-chord')\n\nmodule.exports = T\n"
    },
    "name": "note.midi",
    "kind": "function",
    "memberof": "T",
    "scope": "static",
    "members": {
      "instance": [],
      "static": []
    },
    "events": [],
    "path": [
      "note.midi"
    ]
  },
  {
    "description": "Transpose a note by an interval\nAn alias for `transpose`",
    "tags": [
      {
        "title": "name",
        "description": null,
        "lineNumber": 4,
        "name": "note.transpose"
      },
      {
        "title": "function",
        "description": null,
        "lineNumber": 5,
        "name": null
      },
      {
        "title": "kind",
        "kind": "function"
      },
      {
        "title": "memberof",
        "description": "T.note"
      },
      {
        "title": "static"
      }
    ],
    "loc": {
      "start": {
        "line": 12,
        "column": 0
      },
      "end": {
        "line": 18,
        "column": 3
      }
    },
    "context": {
      "loc": {
        "start": {
          "line": 19,
          "column": 0
        },
        "end": {
          "line": 28,
          "column": 0
        }
      },
      "file": "./packages/tonal/index.js",
      "code": "function T () {}\n\nT.notation = require('music-notation')\nT.note = T.notation.note\nT.interval = T.notation.interval\nT.roman = T.notation.roman\nT.pitch = T.notation.pitch\n\nT.pitchSet = require('pitch-set')\n\n/**\n * Transpose a note by an interval\n * An alias for `transpose`\n *\n * @name note.transpose\n * @function\n */\nT.note.transpose = T.transpose = require('note-transposer')\n\n/**\n * Harmonizes a note by an interval list\n * An alias for `harmonize`\n *\n * @name note.harmonize\n * @function\n */\nT.harmonizer = require('note-harmonizer')\nT.note.harmonize = T.harmonize = T.harmonizer\n\nT.note.interval = require('note-interval')\nT.note.enharmonics = require('enharmonics')\n\n/**\n * Convert from note name to midi number\n * An alias for `midi`\n *\n * @name note.midi\n * @function\n */\nT.midi = T.note.midi = require('note-midi')\n\nT.midi.freq = require('midi-freq')\n\n/**\n * Convert from midi to note number\n * An alias for `midi.note`\n * @name note.fromMidi\n * @function\n */\nT.midi.note = T.note.fromMidi = require('midi-note')\n\nT.gamut = require('music-gamut')\n\nT.dictionary = require('music-dictionary')\nT.scale = require('music-scale')\nT.chord = require('music-chord')\n\nmodule.exports = T\n"
    },
    "name": "note.transpose",
    "kind": "function",
    "memberof": "T.note",
    "scope": "static",
    "members": {
      "instance": [],
      "static": []
    },
    "events": [],
    "path": [
      "note.transpose"
    ]
  },
  {
    "description": "Decorate a function to work with intervals, notes or pitches in\n[array notation](https://github.com/danigb/tonal/tree/next/packages/music-notation)\nwith independence of string representations.\n\nThis is the base of the pluggable notation system of\n[tonal](https://github.com/danigb/tonal)",
    "tags": [
      {
        "title": "name",
        "description": null,
        "lineNumber": 8,
        "name": "operation"
      },
      {
        "title": "function",
        "description": null,
        "lineNumber": 9,
        "name": null
      },
      {
        "title": "param",
        "description": "the parser",
        "lineNumber": 11,
        "type": {
          "type": "NameExpression",
          "name": "Function"
        },
        "name": "parse"
      },
      {
        "title": "param",
        "description": "the string builder",
        "lineNumber": 12,
        "type": {
          "type": "NameExpression",
          "name": "Function"
        },
        "name": "str"
      },
      {
        "title": "param",
        "description": "the operation to decorate",
        "lineNumber": 13,
        "type": {
          "type": "NameExpression",
          "name": "Function"
        },
        "name": "fn"
      },
      {
        "title": "example",
        "description": "var parse = require('music-notation/interval/parse')\nvar str = require('music-notation/interval/str')\nvar operation = require('music-notation/operation')(parse, str)\nvar add = operation(function(a, b) { return [a[0] + b[0], a[1] + b[1]] })\nadd('3m', '3M') // => '5P'",
        "lineNumber": 15
      },
      {
        "title": "kind",
        "kind": "function"
      },
      {
        "title": "memberof",
        "description": "module"
      },
      {
        "title": "static"
      }
    ],
    "loc": {
      "start": {
        "line": 11,
        "column": 0
      },
      "end": {
        "line": 31,
        "column": 3
      }
    },
    "context": {
      "loc": {
        "start": {
          "line": 32,
          "column": 0
        },
        "end": {
          "line": 42,
          "column": 0
        }
      },
      "file": "./packages/music-notation/operation.js",
      "code": "'use strict'\n\nfunction curry (fn, arity) {\n  if (arity === 1) return fn\n  return function (a, b) {\n    if (arguments.length === 1) return function (c) { return fn(a, c) }\n    return fn(a, b)\n  }\n}\n\n/**\n * Decorate a function to work with intervals, notes or pitches in\n * [array notation](https://github.com/danigb/tonal/tree/next/packages/music-notation)\n * with independence of string representations.\n *\n * This is the base of the pluggable notation system of\n * [tonal](https://github.com/danigb/tonal)\n *\n * @name operation\n * @function\n * @param {Function} parse - the parser\n * @param {Function} str - the string builder\n * @param {Function} fn - the operation to decorate\n *\n * @example\n * var parse = require('music-notation/interval/parse')\n * var str = require('music-notation/interval/str')\n * var operation = require('music-notation/operation')(parse, str)\n * var add = operation(function(a, b) { return [a[0] + b[0], a[1] + b[1]] })\n * add('3m', '3M') // => '5P'\n */\nmodule.exports = function op (parse, str, fn) {\n  if (arguments.length === 2) return function (f) { return op(parse, str, f) }\n  return curry(function (a, b) {\n    var ac = parse(a)\n    var bc = parse(b)\n    if (!ac && !bc) return fn(a, b)\n    var v = fn(ac || a, bc || b)\n    return str(v) || v\n  }, fn.length)\n}\n"
    },
    "name": "operation",
    "params": [
      {
        "title": "param",
        "description": "the parser",
        "lineNumber": 11,
        "type": {
          "type": "NameExpression",
          "name": "Function"
        },
        "name": "parse"
      },
      {
        "title": "param",
        "description": "the string builder",
        "lineNumber": 12,
        "type": {
          "type": "NameExpression",
          "name": "Function"
        },
        "name": "str"
      },
      {
        "title": "param",
        "description": "the operation to decorate",
        "lineNumber": 13,
        "type": {
          "type": "NameExpression",
          "name": "Function"
        },
        "name": "fn"
      }
    ],
    "examples": [
      "<span class=\"hljs-keyword\">var</span> parse = <span class=\"hljs-built_in\">require</span>(<span class=\"hljs-string\">'music-notation/interval/parse'</span>)\n<span class=\"hljs-keyword\">var</span> str = <span class=\"hljs-built_in\">require</span>(<span class=\"hljs-string\">'music-notation/interval/str'</span>)\n<span class=\"hljs-keyword\">var</span> operation = <span class=\"hljs-built_in\">require</span>(<span class=\"hljs-string\">'music-notation/operation'</span>)(parse, str)\n<span class=\"hljs-keyword\">var</span> add = operation(<span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span>(<span class=\"hljs-params\">a, b</span>) </span>{ <span class=\"hljs-keyword\">return</span> [a[<span class=\"hljs-number\">0</span>] + b[<span class=\"hljs-number\">0</span>], a[<span class=\"hljs-number\">1</span>] + b[<span class=\"hljs-number\">1</span>]] })\nadd(<span class=\"hljs-string\">'3m'</span>, <span class=\"hljs-string\">'3M'</span>) <span class=\"hljs-comment\">// =&gt; '5P'</span>"
    ],
    "kind": "function",
    "memberof": "module",
    "scope": "static",
    "members": {
      "instance": [],
      "static": []
    },
    "events": [],
    "path": [
      "operation"
    ]
  },
  {
    "description": "Create a pitch set from a list of notes (or intervals) and (optionally) a tonic.\nAn pitch set is a collection of uniq notes or intervals sorted by frequency\n\nThe tonic can be a note (with or without octave), false to get the scale\nintervals or null to set the first note of the source as tonic\n\nThis function is currified, so you can partially apply the function passing\none parameter instead of two (see example)",
    "tags": [
      {
        "title": "name",
        "description": null,
        "lineNumber": 10,
        "name": "pitchSet"
      },
      {
        "title": "function",
        "description": null,
        "lineNumber": 11,
        "name": null
      },
      {
        "title": "param",
        "description": "the list of intervals or notes",
        "lineNumber": 13,
        "type": {
          "type": "NameExpression",
          "name": "Array"
        },
        "name": "source"
      },
      {
        "title": "param",
        "description": "the tonic of the scale",
        "lineNumber": 14,
        "type": {
          "type": "NameExpression",
          "name": "String"
        },
        "name": "tonic"
      },
      {
        "title": "returns",
        "description": "the list of notes",
        "lineNumber": 15,
        "type": {
          "type": "NameExpression",
          "name": "Array"
        }
      },
      {
        "title": "example",
        "description": "var pitchSet = require('pitch-set')\n\n// pitch sets from notes (uses first note as tonic)\npitchSet('d2 c4 e3 f g6 a B c d5 e', null) // => ['D', 'E', 'F', 'gamut', 'A', 'B', 'C']\n\n// pitch sets from intervals\npitchSet('1 2 3 5 6', 'G') // => ['G', 'A', 'B', 'D', 'E']\npitchSet('1 2 3 5 6', false) // => ['1P', '2M', '3M', '5P', '6M']\n\n// partially applied\nvar dorian = pitchSet('D E F gamut A B C')\ndorian('C4') // => ['C4', 'D4', 'Eb4', 'F4', 'gamut4', 'A4', 'Bb4']",
        "lineNumber": 17
      },
      {
        "title": "kind",
        "kind": "function"
      },
      {
        "title": "memberof",
        "description": "module"
      },
      {
        "title": "static"
      }
    ],
    "loc": {
      "start": {
        "line": 6,
        "column": 0
      },
      "end": {
        "line": 35,
        "column": 3
      }
    },
    "context": {
      "loc": {
        "start": {
          "line": 36,
          "column": 0
        },
        "end": {
          "line": 46,
          "column": 0
        }
      },
      "file": "./packages/pitch-set/index.js",
      "code": "'use strict'\n\nvar gamut = require('music-gamut')\nvar harmonize = require('note-harmonizer')\n\n/**\n * Create a pitch set from a list of notes (or intervals) and (optionally) a tonic.\n * An pitch set is a collection of uniq notes or intervals sorted by frequency\n *\n * The tonic can be a note (with or without octave), false to get the scale\n * intervals or null to set the first note of the source as tonic\n *\n * This function is currified, so you can partially apply the function passing\n * one parameter instead of two (see example)\n *\n * @name pitchSet\n * @function\n * @param {Array} source - the list of intervals or notes\n * @param {String} tonic - the tonic of the scale\n * @return {Array} the list of notes\n *\n * @example\n * var pitchSet = require('pitch-set')\n\n * // pitch sets from notes (uses first note as tonic)\n * pitchSet('d2 c4 e3 f g6 a B c d5 e', null) // => ['D', 'E', 'F', 'gamut', 'A', 'B', 'C']\n *\n * // pitch sets from intervals\n * pitchSet('1 2 3 5 6', 'G') // => ['G', 'A', 'B', 'D', 'E']\n * pitchSet('1 2 3 5 6', false) // => ['1P', '2M', '3M', '5P', '6M']\n *\n * // partially applied\n * var dorian = pitchSet('D E F gamut A B C')\n * dorian('C4') // => ['C4', 'D4', 'Eb4', 'F4', 'gamut4', 'A4', 'Bb4']\n */\nmodule.exports = function set (source, tonic) {\n  if (arguments.length === 1) return function (t) { return set(source, t) }\n  return gamut.operation(function (src) {\n    if (src.length === 0) return []\n    var set = uniq(src.map(simplify))\n    if (areNotes(set)) set = rotate(src[0], set)\n    return harmonize(set, tonic)\n  })(source)\n}\n\nfunction areNotes (g) { return g[0].length !== 2 }\n\nfunction simplify (p) {\n  return p.length === 2 ? [p[0], -Math.floor(p[0] * 7 / 12)] : [p[0]]\n}\n\nfunction eq (a, b) { return a[0] === b[0] }\n\nfunction indexOf (p, gamut) {\n  for (var i = 0, l = gamut.length; i < l; i++) {\n    if (eq(p, gamut[i])) return i\n  }\n}\n\nfunction rotate (first, uniq) {\n  return gamut.rotate(indexOf(first, uniq), uniq)\n}\n\nfunction uniq (src) {\n  var sorted = gamut.sort(src)\n  return sorted.reduce(function (uniq, value, index) {\n    if (index === 0 || !eq(sorted[index - 1], value)) uniq.push(value)\n    return uniq\n  }, [])\n}"
    },
    "name": "pitchSet",
    "params": [
      {
        "title": "param",
        "description": "the list of intervals or notes",
        "lineNumber": 13,
        "type": {
          "type": "NameExpression",
          "name": "Array"
        },
        "name": "source"
      },
      {
        "title": "param",
        "description": "the tonic of the scale",
        "lineNumber": 14,
        "type": {
          "type": "NameExpression",
          "name": "String"
        },
        "name": "tonic"
      }
    ],
    "returns": [
      {
        "title": "returns",
        "description": "the list of notes",
        "lineNumber": 15,
        "type": {
          "type": "NameExpression",
          "name": "Array"
        }
      }
    ],
    "examples": [
      "<span class=\"hljs-keyword\">var</span> pitchSet = <span class=\"hljs-built_in\">require</span>(<span class=\"hljs-string\">'pitch-set'</span>)\n\n<span class=\"hljs-comment\">// pitch sets from notes (uses first note as tonic)</span>\npitchSet(<span class=\"hljs-string\">'d2 c4 e3 f g6 a B c d5 e'</span>, <span class=\"hljs-literal\">null</span>) <span class=\"hljs-comment\">// =&gt; ['D', 'E', 'F', 'gamut', 'A', 'B', 'C']</span>\n\n<span class=\"hljs-comment\">// pitch sets from intervals</span>\npitchSet(<span class=\"hljs-string\">'1 2 3 5 6'</span>, <span class=\"hljs-string\">'G'</span>) <span class=\"hljs-comment\">// =&gt; ['G', 'A', 'B', 'D', 'E']</span>\npitchSet(<span class=\"hljs-string\">'1 2 3 5 6'</span>, <span class=\"hljs-literal\">false</span>) <span class=\"hljs-comment\">// =&gt; ['1P', '2M', '3M', '5P', '6M']</span>\n\n<span class=\"hljs-comment\">// partially applied</span>\n<span class=\"hljs-keyword\">var</span> dorian = pitchSet(<span class=\"hljs-string\">'D E F gamut A B C'</span>)\ndorian(<span class=\"hljs-string\">'C4'</span>) <span class=\"hljs-comment\">// =&gt; ['C4', 'D4', 'Eb4', 'F4', 'gamut4', 'A4', 'Bb4']</span>"
    ],
    "kind": "function",
    "memberof": "module",
    "scope": "static",
    "members": {
      "instance": [],
      "static": []
    },
    "events": [],
    "path": [
      "pitchSet"
    ]
  },
  {
    "description": "A scale dictionary. Get scale from a scale name and a tonic.\n\nThe dictionary has a `names` property with all scale names.",
    "tags": [
      {
        "title": "name",
        "description": null,
        "lineNumber": 5,
        "name": "scale"
      },
      {
        "title": "function",
        "description": null,
        "lineNumber": 6,
        "name": null
      },
      {
        "title": "param",
        "description": "the scale name",
        "lineNumber": 8,
        "type": {
          "type": "NameExpression",
          "name": "String"
        },
        "name": "name"
      },
      {
        "title": "see",
        "description": "music-dictionary",
        "lineNumber": 9
      },
      {
        "title": "example",
        "description": "// get scale data\nvar scale = require('scale-dictionary')\nscale('Ab major') // => [ 'Ab', 'Bb', 'C', 'Db', 'Eb', 'F', 'G' ]\nscale('major', 'Ab') // => [ 'Ab', 'Bb', 'C', 'Db', 'Eb', 'F', 'G' ]\n// get scale intervals\nscale('major', false) // => [ '1P', '2M', '3M', '4P', '5P', '6M', '7M' ]",
        "lineNumber": 11
      },
      {
        "title": "example",
        "description": "// get it from aliases, binary or decimal numbers\nscale('major') === scale('ionian') === scale('101011010101') === scale(2773)",
        "lineNumber": 19
      },
      {
        "title": "example",
        "description": "// get scale names\nscale.names // => ['major', 'dorian', ...]",
        "lineNumber": 23
      },
      {
        "title": "kind",
        "kind": "function"
      },
      {
        "title": "memberof",
        "description": "module"
      },
      {
        "title": "static"
      }
    ],
    "loc": {
      "start": {
        "line": 6,
        "column": 0
      },
      "end": {
        "line": 31,
        "column": 3
      }
    },
    "context": {
      "loc": {
        "start": {
          "line": 32,
          "column": 0
        },
        "end": {
          "line": 33,
          "column": 0
        }
      },
      "file": "./packages/scale-dictionary/index.js",
      "code": "'use strict'\n\nvar scales = require('./scales.json')\nvar dictionary = require('music-dictionary')\n\n/**\n * A scale dictionary. Get scale from a scale name and a tonic.\n *\n * The dictionary has a `names` property with all scale names.\n *\n * @name scale\n * @function\n * @param {String} name - the scale name\n * @see music-dictionary\n *\n * @example\n * // get scale data\n * var scale = require('scale-dictionary')\n * scale('Ab major') // => [ 'Ab', 'Bb', 'C', 'Db', 'Eb', 'F', 'G' ]\n * scale('major', 'Ab') // => [ 'Ab', 'Bb', 'C', 'Db', 'Eb', 'F', 'G' ]\n * // get scale intervals\n * scale('major', false) // => [ '1P', '2M', '3M', '4P', '5P', '6M', '7M' ]\n *\n * @example\n * // get it from aliases, binary or decimal numbers\n * scale('major') === scale('ionian') === scale('101011010101') === scale(2773)\n *\n * @example\n * // get scale names\n * scale.names // => ['major', 'dorian', ...]\n */\nmodule.exports = dictionary(scales)\n"
    },
    "name": "scale",
    "params": [
      {
        "title": "param",
        "description": "the scale name",
        "lineNumber": 8,
        "type": {
          "type": "NameExpression",
          "name": "String"
        },
        "name": "name"
      }
    ],
    "examples": [
      "<span class=\"hljs-comment\">// get scale data</span>\n<span class=\"hljs-keyword\">var</span> scale = <span class=\"hljs-built_in\">require</span>(<span class=\"hljs-string\">'scale-dictionary'</span>)\nscale(<span class=\"hljs-string\">'Ab major'</span>) <span class=\"hljs-comment\">// =&gt; [ 'Ab', 'Bb', 'C', 'Db', 'Eb', 'F', 'G' ]</span>\nscale(<span class=\"hljs-string\">'major'</span>, <span class=\"hljs-string\">'Ab'</span>) <span class=\"hljs-comment\">// =&gt; [ 'Ab', 'Bb', 'C', 'Db', 'Eb', 'F', 'G' ]</span>\n<span class=\"hljs-comment\">// get scale intervals</span>\nscale(<span class=\"hljs-string\">'major'</span>, <span class=\"hljs-literal\">false</span>) <span class=\"hljs-comment\">// =&gt; [ '1P', '2M', '3M', '4P', '5P', '6M', '7M' ]</span>",
      "<span class=\"hljs-comment\">// get it from aliases, binary or decimal numbers</span>\nscale(<span class=\"hljs-string\">'major'</span>) === scale(<span class=\"hljs-string\">'ionian'</span>) === scale(<span class=\"hljs-string\">'101011010101'</span>) === scale(<span class=\"hljs-number\">2773</span>)",
      "<span class=\"hljs-comment\">// get scale names</span>\nscale.names <span class=\"hljs-comment\">// =&gt; ['major', 'dorian', ...]</span>"
    ],
    "kind": "function",
    "memberof": "module",
    "scope": "static",
    "members": {
      "instance": [],
      "static": [
        {
          "description": "Get available scale names",
          "tags": [
            {
              "title": "name",
              "description": null,
              "lineNumber": 2,
              "name": "scale.names"
            },
            {
              "title": "function",
              "description": null,
              "lineNumber": 3,
              "name": null
            },
            {
              "title": "param",
              "description": "if true, it returns the name aliases",
              "lineNumber": 5,
              "type": {
                "type": "NameExpression",
                "name": "Boolean"
              },
              "name": "aliases"
            },
            {
              "title": "returns",
              "description": "the available scale names",
              "lineNumber": 6,
              "type": {
                "type": "NameExpression",
                "name": "Array"
              }
            },
            {
              "title": "kind",
              "kind": "function"
            },
            {
              "title": "memberof",
              "description": "scale"
            },
            {
              "title": "static"
            }
          ],
          "loc": {
            "start": {
              "line": 28,
              "column": 0
            },
            "end": {
              "line": 34,
              "column": 3
            }
          },
          "context": {
            "loc": {
              "start": {
                "line": 35,
                "column": 0
              },
              "end": {
                "line": 45,
                "column": 0
              }
            },
            "file": "./packages/music-scale/index.js",
            "code": "'use strict'\n\nvar set = require('pitch-set')\nvar dictionary = require('scale-dictionary')\n\n/**\n * Create a scale from a name or intervals and tonic\n *\n * @name scale\n * @function\n * @param {Array} source - the scale name, scale intervals or scale notes\n * @param {String} tonic - the tonic of the scale\n * @return {Array} the list of notes\n *\n * @example\n * var scale = require('music-scale')\n */\nfunction scale (source, tonic) {\n  var s\n  if (arguments.length === 1) {\n    s = dictionary(source)\n    return typeof s === 'function' ? function (t) { return scale(source, t) } : s\n  }\n  s = dictionary(source, tonic)\n  return s.length ? s : set(source, tonic)\n}\n\n/**\n * Get available scale names\n * @name scale.names\n * @function\n * @param {Boolean} aliases - if true, it returns the name aliases\n * @return {Array} the available scale names\n */\nscale.names = dictionary.names\n\n/**\n * Get scale properties\n *\n * @name scale.props\n * @function\n * @param {String} name - the scale name\n * @return {Object} the scale properties\n */\nscale.props = dictionary.props\n\nmodule.exports = scale\n"
          },
          "name": "scale.names",
          "params": [
            {
              "title": "param",
              "description": "if true, it returns the name aliases",
              "lineNumber": 5,
              "type": {
                "type": "NameExpression",
                "name": "Boolean"
              },
              "name": "aliases"
            }
          ],
          "returns": [
            {
              "title": "returns",
              "description": "the available scale names",
              "lineNumber": 6,
              "type": {
                "type": "NameExpression",
                "name": "Array"
              }
            }
          ],
          "kind": "function",
          "memberof": "scale",
          "scope": "static",
          "members": {
            "instance": [],
            "static": []
          },
          "events": [],
          "path": [
            "scale",
            "scale.names"
          ]
        },
        {
          "description": "Get scale properties",
          "tags": [
            {
              "title": "name",
              "description": null,
              "lineNumber": 3,
              "name": "scale.props"
            },
            {
              "title": "function",
              "description": null,
              "lineNumber": 4,
              "name": null
            },
            {
              "title": "param",
              "description": "the scale name",
              "lineNumber": 6,
              "type": {
                "type": "NameExpression",
                "name": "String"
              },
              "name": "name"
            },
            {
              "title": "returns",
              "description": "the scale properties",
              "lineNumber": 7,
              "type": {
                "type": "NameExpression",
                "name": "Object"
              }
            },
            {
              "title": "kind",
              "kind": "function"
            },
            {
              "title": "memberof",
              "description": "scale"
            },
            {
              "title": "static"
            }
          ],
          "loc": {
            "start": {
              "line": 37,
              "column": 0
            },
            "end": {
              "line": 44,
              "column": 3
            }
          },
          "context": {
            "loc": {
              "start": {
                "line": 45,
                "column": 0
              },
              "end": {
                "line": 47,
                "column": 0
              }
            },
            "file": "./packages/music-scale/index.js",
            "code": "'use strict'\n\nvar set = require('pitch-set')\nvar dictionary = require('scale-dictionary')\n\n/**\n * Create a scale from a name or intervals and tonic\n *\n * @name scale\n * @function\n * @param {Array} source - the scale name, scale intervals or scale notes\n * @param {String} tonic - the tonic of the scale\n * @return {Array} the list of notes\n *\n * @example\n * var scale = require('music-scale')\n */\nfunction scale (source, tonic) {\n  var s\n  if (arguments.length === 1) {\n    s = dictionary(source)\n    return typeof s === 'function' ? function (t) { return scale(source, t) } : s\n  }\n  s = dictionary(source, tonic)\n  return s.length ? s : set(source, tonic)\n}\n\n/**\n * Get available scale names\n * @name scale.names\n * @function\n * @param {Boolean} aliases - if true, it returns the name aliases\n * @return {Array} the available scale names\n */\nscale.names = dictionary.names\n\n/**\n * Get scale properties\n *\n * @name scale.props\n * @function\n * @param {String} name - the scale name\n * @return {Object} the scale properties\n */\nscale.props = dictionary.props\n\nmodule.exports = scale\n"
          },
          "name": "scale.props",
          "params": [
            {
              "title": "param",
              "description": "the scale name",
              "lineNumber": 6,
              "type": {
                "type": "NameExpression",
                "name": "String"
              },
              "name": "name"
            }
          ],
          "returns": [
            {
              "title": "returns",
              "description": "the scale properties",
              "lineNumber": 7,
              "type": {
                "type": "NameExpression",
                "name": "Object"
              }
            }
          ],
          "kind": "function",
          "memberof": "scale",
          "scope": "static",
          "members": {
            "instance": [],
            "static": []
          },
          "events": [],
          "path": [
            "scale",
            "scale.props"
          ]
        }
      ]
    },
    "events": [],
    "path": [
      "scale"
    ]
  },
  {
    "description": "Create a scale from a name or intervals and tonic",
    "tags": [
      {
        "title": "name",
        "description": null,
        "lineNumber": 3,
        "name": "scale"
      },
      {
        "title": "function",
        "description": null,
        "lineNumber": 4,
        "name": null
      },
      {
        "title": "param",
        "description": "the scale name, scale intervals or scale notes",
        "lineNumber": 6,
        "type": {
          "type": "NameExpression",
          "name": "Array"
        },
        "name": "source"
      },
      {
        "title": "param",
        "description": "the tonic of the scale",
        "lineNumber": 7,
        "type": {
          "type": "NameExpression",
          "name": "String"
        },
        "name": "tonic"
      },
      {
        "title": "returns",
        "description": "the list of notes",
        "lineNumber": 8,
        "type": {
          "type": "NameExpression",
          "name": "Array"
        }
      },
      {
        "title": "example",
        "description": "var scale = require('music-scale')",
        "lineNumber": 10
      },
      {
        "title": "kind",
        "kind": "function"
      }
    ],
    "loc": {
      "start": {
        "line": 6,
        "column": 0
      },
      "end": {
        "line": 17,
        "column": 3
      }
    },
    "context": {
      "loc": {
        "start": {
          "line": 18,
          "column": 0
        },
        "end": {
          "line": 26,
          "column": 1
        }
      },
      "file": "./packages/music-scale/index.js",
      "code": "'use strict'\n\nvar set = require('pitch-set')\nvar dictionary = require('scale-dictionary')\n\n/**\n * Create a scale from a name or intervals and tonic\n *\n * @name scale\n * @function\n * @param {Array} source - the scale name, scale intervals or scale notes\n * @param {String} tonic - the tonic of the scale\n * @return {Array} the list of notes\n *\n * @example\n * var scale = require('music-scale')\n */\nfunction scale (source, tonic) {\n  var s\n  if (arguments.length === 1) {\n    s = dictionary(source)\n    return typeof s === 'function' ? function (t) { return scale(source, t) } : s\n  }\n  s = dictionary(source, tonic)\n  return s.length ? s : set(source, tonic)\n}\n\n/**\n * Get available scale names\n * @name scale.names\n * @function\n * @param {Boolean} aliases - if true, it returns the name aliases\n * @return {Array} the available scale names\n */\nscale.names = dictionary.names\n\n/**\n * Get scale properties\n *\n * @name scale.props\n * @function\n * @param {String} name - the scale name\n * @return {Object} the scale properties\n */\nscale.props = dictionary.props\n\nmodule.exports = scale\n"
    },
    "name": "scale",
    "params": [
      {
        "title": "param",
        "description": "the scale name, scale intervals or scale notes",
        "lineNumber": 6,
        "type": {
          "type": "NameExpression",
          "name": "Array"
        },
        "name": "source"
      },
      {
        "title": "param",
        "description": "the tonic of the scale",
        "lineNumber": 7,
        "type": {
          "type": "NameExpression",
          "name": "String"
        },
        "name": "tonic"
      }
    ],
    "returns": [
      {
        "title": "returns",
        "description": "the list of notes",
        "lineNumber": 8,
        "type": {
          "type": "NameExpression",
          "name": "Array"
        }
      }
    ],
    "examples": [
      "<span class=\"hljs-keyword\">var</span> scale = <span class=\"hljs-built_in\">require</span>(<span class=\"hljs-string\">'music-scale'</span>)"
    ],
    "kind": "function",
    "members": {
      "instance": [],
      "static": []
    },
    "events": [],
    "path": [
      "scale"
    ]
  },
  {
    "description": "Get the size in semitones of an interval or a note. If applied to a note, it\nget the size in semitones from 'C0' to that note.",
    "tags": [
      {
        "title": "name",
        "description": null,
        "lineNumber": 4,
        "name": "semitones"
      },
      {
        "title": "function",
        "description": null,
        "lineNumber": 5,
        "name": null
      },
      {
        "title": "param",
        "description": "the pitch to get the semitones size from (in\nstring or array notetion)",
        "lineNumber": 7,
        "type": {
          "type": "UnionType",
          "elements": [
            {
              "type": "NameExpression",
              "name": "String"
            },
            {
              "type": "NameExpression",
              "name": "Array"
            }
          ]
        },
        "name": "pitch"
      },
      {
        "title": "returns",
        "description": "the size in semitones, null if not valid pitch",
        "lineNumber": 9,
        "type": {
          "type": "NameExpression",
          "name": "Integer"
        }
      },
      {
        "title": "example",
        "description": "var semitones = require('semitones')\nsemitones('P4') // => 5",
        "lineNumber": 11
      },
      {
        "title": "kind",
        "kind": "function"
      },
      {
        "title": "memberof",
        "description": "module"
      },
      {
        "title": "static"
      }
    ],
    "loc": {
      "start": {
        "line": 5,
        "column": 0
      },
      "end": {
        "line": 18,
        "column": 3
      }
    },
    "context": {
      "loc": {
        "start": {
          "line": 19,
          "column": 0
        },
        "end": {
          "line": 26,
          "column": 0
        }
      },
      "file": "./packages/semitones/index.js",
      "code": "'use strict'\n\nvar parse = require('music-notation/pitch/parse')\n\n/**\n * Get the size in semitones of an interval or a note. If applied to a note, it\n * get the size in semitones from 'C0' to that note.\n *\n * @name semitones\n * @function\n * @param {String|Array} pitch - the pitch to get the semitones size from (in\n * string or array notetion)\n * @return {Integer} the size in semitones, null if not valid pitch\n *\n * @example\n * var semitones = require('semitones')\n * semitones('P4') // => 5\n */\nmodule.exports = function (pitch) {\n  var p = Array.isArray(pitch) ? pitch : parse(pitch)\n  if (!p) return null\n  var f = p[0] * 7\n  var o = p.length > 1 ? p[1] : -Math.floor(f / 12)\n  return f + o * 12\n}\n"
    },
    "name": "semitones",
    "params": [
      {
        "title": "param",
        "description": "the pitch to get the semitones size from (in\nstring or array notetion)",
        "lineNumber": 7,
        "type": {
          "type": "UnionType",
          "elements": [
            {
              "type": "NameExpression",
              "name": "String"
            },
            {
              "type": "NameExpression",
              "name": "Array"
            }
          ]
        },
        "name": "pitch"
      }
    ],
    "returns": [
      {
        "title": "returns",
        "description": "the size in semitones, null if not valid pitch",
        "lineNumber": 9,
        "type": {
          "type": "NameExpression",
          "name": "Integer"
        }
      }
    ],
    "examples": [
      "<span class=\"hljs-keyword\">var</span> semitones = <span class=\"hljs-built_in\">require</span>(<span class=\"hljs-string\">'semitones'</span>)\nsemitones(<span class=\"hljs-string\">'P4'</span>) <span class=\"hljs-comment\">// =&gt; 5</span>"
    ],
    "kind": "function",
    "memberof": "module",
    "scope": "static",
    "members": {
      "instance": [],
      "static": []
    },
    "events": [],
    "path": [
      "semitones"
    ]
  },
  {
    "description": "Get a set from a binary set number and (optionally) a tonic. If the tonic is\na note, you get a pitch set. If its false you get a interval set.",
    "tags": [
      {
        "title": "name",
        "description": null,
        "lineNumber": 4,
        "name": "set.fromBinary"
      },
      {
        "title": "function",
        "description": null,
        "lineNumber": 5,
        "name": null
      },
      {
        "title": "param",
        "description": "the gamut",
        "lineNumber": 7,
        "type": {
          "type": "UnionType",
          "elements": [
            {
              "type": "NameExpression",
              "name": "String"
            },
            {
              "type": "NameExpression",
              "name": "Array"
            },
            {
              "type": "TypeApplication",
              "expression": {
                "type": "NameExpression",
                "name": "Array"
              },
              "applications": [
                {
                  "type": "NameExpression",
                  "name": "Array"
                }
              ]
            }
          ]
        },
        "name": "source"
      },
      {
        "title": "param",
        "description": "the first note of the set or false to get the intervals",
        "lineNumber": 8,
        "type": {
          "type": "NameExpression",
          "name": "String"
        },
        "name": "tonic"
      },
      {
        "title": "returns",
        "description": "the set pitch classes (note names without octaves)",
        "lineNumber": 9,
        "type": {
          "type": "TypeApplication",
          "expression": {
            "type": "NameExpression",
            "name": "Array"
          },
          "applications": [
            {
              "type": "NameExpression",
              "name": "String"
            }
          ]
        }
      },
      {
        "title": "example",
        "description": "var fromBinary = require('tonal.set/fromBinary')\n// use a 12 digit binary number:\nfromBinary('101011010101', 'C') // => ['C', 'D', 'E', 'F', 'G', 'A', 'B']\n// or its decimal equivalent:\nfromBinary(2773, 'C') // => ['C', 'D', 'E', 'F', 'G', 'A', 'B']\n// get the interval set by passing `false` as tonic:\nfromBinary(2773, false) // => ['1P', '2M', '3M', '4', '5', '6M', '7M']",
        "lineNumber": 11
      },
      {
        "title": "kind",
        "kind": "function"
      },
      {
        "title": "memberof",
        "description": "bs"
      },
      {
        "title": "static"
      }
    ],
    "loc": {
      "start": {
        "line": 38,
        "column": 0
      },
      "end": {
        "line": 56,
        "column": 3
      }
    },
    "context": {
      "loc": {
        "start": {
          "line": 57,
          "column": 0
        },
        "end": {
          "line": 74,
          "column": 0
        }
      },
      "file": "./packages/binary-set/index.js",
      "code": "'use strict'\n\nvar set = require('pitch-set')\nvar transpose = require('note-transposer')\nvar semitones = require('semitones')\n\nvar bs = {}\n\n/**\n * Get a set binary number from a collection of notes or intervals\n *\n * A set binary number is a 12 digit binary, each digit representing a step\n * in the chromatic scale. For example, `101010000000` is `['1P', '2M', '3M']`\n *\n * The set binary number is very useful to check if two sets are equal or\n * contains same intervals (regarding of note names)\n *\n * @name binarySet.toBinary\n * @function\n * @param {String|Array|Array<Array>} source - a gamut\n * @return {String} the binary number\n *\n * @example\n * var binarySet = require('binary-set')\n * binarySet.toBinary('C2 E4 D3') // => '101010000000'\n */\nbs.toBinary = function (gamut) {\n  var number = [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]\n  var sizes = set(gamut, false).map(semitones)\n  sizes.forEach(function (s) {\n    number[s] = 1\n  })\n  return number.join('')\n}\n\nvar INTERVALS = ['1P', '2m', '2M', '3m', '3M', '4P', '4#', '5P', '6m', '6M', '7m', '7M']\n\n/**\n * Get a set from a binary set number and (optionally) a tonic. If the tonic is\n * a note, you get a pitch set. If its false you get a interval set.\n *\n * @name set.fromBinary\n * @function\n * @param {String|Array|Array<Array>} source - the gamut\n * @param {String} tonic - the first note of the set or false to get the intervals\n * @return {Array<String>} the set pitch classes (note names without octaves)\n *\n * @example\n * var fromBinary = require('tonal.set/fromBinary')\n * // use a 12 digit binary number:\n * fromBinary('101011010101', 'C') // => ['C', 'D', 'E', 'F', 'G', 'A', 'B']\n * // or its decimal equivalent:\n * fromBinary(2773, 'C') // => ['C', 'D', 'E', 'F', 'G', 'A', 'B']\n * // get the interval set by passing `false` as tonic:\n * fromBinary(2773, false) // => ['1P', '2M', '3M', '4', '5', '6M', '7M']\n */\nbs.fromBinary = function (number, tonic) {\n  if (arguments.length === 1) return function (t) { return bs.fromBinary(number, t) }\n\n  if (/^1[01]{11}$/.test(number)) number = parseInt(number, 2)\n  else if (typeof number !== 'number') return []\n  var binary = ((number % 2048) + 2048).toString(2)\n\n  var set = []\n  for (var i = 0; i < 12; i++) {\n    if (binary.charAt(i) === '1') {\n      if (i === 6 && binary.charAt(5) === '1') set.push('5d')\n      else set.push(INTERVALS[i])\n    }\n  }\n  return tonic === false ? set : set.map(transpose(tonic))\n}\n\nmodule.exports = bs\n"
    },
    "name": "set.fromBinary",
    "params": [
      {
        "title": "param",
        "description": "the gamut",
        "lineNumber": 7,
        "type": {
          "type": "UnionType",
          "elements": [
            {
              "type": "NameExpression",
              "name": "String"
            },
            {
              "type": "NameExpression",
              "name": "Array"
            },
            {
              "type": "TypeApplication",
              "expression": {
                "type": "NameExpression",
                "name": "Array"
              },
              "applications": [
                {
                  "type": "NameExpression",
                  "name": "Array"
                }
              ]
            }
          ]
        },
        "name": "source"
      },
      {
        "title": "param",
        "description": "the first note of the set or false to get the intervals",
        "lineNumber": 8,
        "type": {
          "type": "NameExpression",
          "name": "String"
        },
        "name": "tonic"
      }
    ],
    "returns": [
      {
        "title": "returns",
        "description": "the set pitch classes (note names without octaves)",
        "lineNumber": 9,
        "type": {
          "type": "TypeApplication",
          "expression": {
            "type": "NameExpression",
            "name": "Array"
          },
          "applications": [
            {
              "type": "NameExpression",
              "name": "String"
            }
          ]
        }
      }
    ],
    "examples": [
      "<span class=\"hljs-keyword\">var</span> fromBinary = <span class=\"hljs-built_in\">require</span>(<span class=\"hljs-string\">'tonal.set/fromBinary'</span>)\n<span class=\"hljs-comment\">// use a 12 digit binary number:</span>\nfromBinary(<span class=\"hljs-string\">'101011010101'</span>, <span class=\"hljs-string\">'C'</span>) <span class=\"hljs-comment\">// =&gt; ['C', 'D', 'E', 'F', 'G', 'A', 'B']</span>\n<span class=\"hljs-comment\">// or its decimal equivalent:</span>\nfromBinary(<span class=\"hljs-number\">2773</span>, <span class=\"hljs-string\">'C'</span>) <span class=\"hljs-comment\">// =&gt; ['C', 'D', 'E', 'F', 'G', 'A', 'B']</span>\n<span class=\"hljs-comment\">// get the interval set by passing `false` as tonic:</span>\nfromBinary(<span class=\"hljs-number\">2773</span>, <span class=\"hljs-literal\">false</span>) <span class=\"hljs-comment\">// =&gt; ['1P', '2M', '3M', '4', '5', '6M', '7M']</span>"
    ],
    "kind": "function",
    "memberof": "bs",
    "scope": "static",
    "members": {
      "instance": [],
      "static": []
    },
    "events": [],
    "path": [
      "set.fromBinary"
    ]
  },
  {
    "description": "Sort a collection of notes or intervals. It can sort in ascending or descending\npitch order or using a custom comparator.\n\nThis function is currified",
    "tags": [
      {
        "title": "name",
        "description": null,
        "lineNumber": 6,
        "name": "sort"
      },
      {
        "title": "function",
        "description": null,
        "lineNumber": 7,
        "name": null
      },
      {
        "title": "param",
        "description": "the comparator function, or true to\nsort in ascending pitch order or false to sort in descending pitch order",
        "lineNumber": 9,
        "type": {
          "type": "UnionType",
          "elements": [
            {
              "type": "NameExpression",
              "name": "Function"
            },
            {
              "type": "NameExpression",
              "name": "Boolean"
            }
          ]
        },
        "name": "comparator"
      },
      {
        "title": "param",
        "description": "the notes or intervals list",
        "lineNumber": 11,
        "type": {
          "type": "UnionType",
          "elements": [
            {
              "type": "NameExpression",
              "name": "String"
            },
            {
              "type": "NameExpression",
              "name": "Array"
            }
          ]
        },
        "name": "source"
      },
      {
        "title": "returns",
        "description": "the notes or intervals sorted",
        "lineNumber": 12,
        "type": {
          "type": "NameExpression",
          "name": "Array"
        }
      },
      {
        "title": "example",
        "description": "var sort = require('note-sorter')\nsort(true, 'c5 d2 f4 D2') // => ['D2', 'D2', 'F4', 'C5']\nsort(false, 'c5 d2 f4 D2') // => ['C5', 'F4', 'D2', 'D2']\n\n// partially applied\nvar descending = sort(false)\ndescending('C D E F G') // => [ 'G', 'F', 'E', 'D', 'C' ]",
        "lineNumber": 14
      },
      {
        "title": "kind",
        "kind": "function"
      }
    ],
    "loc": {
      "start": {
        "line": 11,
        "column": 0
      },
      "end": {
        "line": 32,
        "column": 3
      }
    },
    "context": {
      "loc": {
        "start": {
          "line": 33,
          "column": 0
        },
        "end": {
          "line": 38,
          "column": 1
        }
      },
      "file": "./packages/pitch-sort/index.js",
      "code": "module.exports = \n/**\n * Sort a collection of notes or intervals. It can sort in ascending or descending\n * pitch order or using a custom comparator.\n *\n * This function is currified\n *\n * @name sort\n * @function\n * @param {Function|Boolean} comparator - the comparator function, or true to\n * sort in ascending pitch order or false to sort in descending pitch order\n * @param {String|Array} source - the notes or intervals list\n * @return {Array} the notes or intervals sorted\n *\n * @example\n * var sort = require('note-sorter')\n * sort(true, 'c5 d2 f4 D2') // => ['D2', 'D2', 'F4', 'C5']\n * sort(false, 'c5 d2 f4 D2') // => ['C5', 'F4', 'D2', 'D2']\n *\n * // partially applied\n * var descending = sort(false)\n * descending('C D E F G') // => [ 'G', 'F', 'E', 'D', 'C' ]\n */\nfunction sort (comp, source) {\n  if (arguments.length > 1) return sort(comp)(source)\n  if (comp === null || comp === true) comp = asc\n  else if (comp === false) comp = desc\n  return gamut.operation(function (g) { return g.sort(comp) })\n}"
    },
    "name": "sort",
    "params": [
      {
        "title": "param",
        "description": "the comparator function, or true to\nsort in ascending pitch order or false to sort in descending pitch order",
        "lineNumber": 9,
        "type": {
          "type": "UnionType",
          "elements": [
            {
              "type": "NameExpression",
              "name": "Function"
            },
            {
              "type": "NameExpression",
              "name": "Boolean"
            }
          ]
        },
        "name": "comparator"
      },
      {
        "title": "param",
        "description": "the notes or intervals list",
        "lineNumber": 11,
        "type": {
          "type": "UnionType",
          "elements": [
            {
              "type": "NameExpression",
              "name": "String"
            },
            {
              "type": "NameExpression",
              "name": "Array"
            }
          ]
        },
        "name": "source"
      }
    ],
    "returns": [
      {
        "title": "returns",
        "description": "the notes or intervals sorted",
        "lineNumber": 12,
        "type": {
          "type": "NameExpression",
          "name": "Array"
        }
      }
    ],
    "examples": [
      "<span class=\"hljs-keyword\">var</span> sort = <span class=\"hljs-built_in\">require</span>(<span class=\"hljs-string\">'note-sorter'</span>)\nsort(<span class=\"hljs-literal\">true</span>, <span class=\"hljs-string\">'c5 d2 f4 D2'</span>) <span class=\"hljs-comment\">// =&gt; ['D2', 'D2', 'F4', 'C5']</span>\nsort(<span class=\"hljs-literal\">false</span>, <span class=\"hljs-string\">'c5 d2 f4 D2'</span>) <span class=\"hljs-comment\">// =&gt; ['C5', 'F4', 'D2', 'D2']</span>\n\n<span class=\"hljs-comment\">// partially applied</span>\n<span class=\"hljs-keyword\">var</span> descending = sort(<span class=\"hljs-literal\">false</span>)\ndescending(<span class=\"hljs-string\">'C D E F G'</span>) <span class=\"hljs-comment\">// =&gt; [ 'G', 'F', 'E', 'D', 'C' ]</span>"
    ],
    "kind": "function",
    "members": {
      "instance": [],
      "static": []
    },
    "events": [],
    "path": [
      "sort"
    ]
  },
  {
    "description": "Transposes a note by an interval.\n\nGiven a note and an interval it returns the transposed note. It can be used\nto add intervals if both parameters are intervals.\n\nThe order of the parameters is indifferent.\n\nThis function is currified so it can be used to map arrays of notes.",
    "tags": [
      {
        "title": "name",
        "description": null,
        "lineNumber": 10,
        "name": "transpose"
      },
      {
        "title": "function",
        "description": null,
        "lineNumber": 11,
        "name": null
      },
      {
        "title": "param",
        "description": "the interval. If its false, the note is not\ntransposed.",
        "lineNumber": 13,
        "type": {
          "type": "UnionType",
          "elements": [
            {
              "type": "NameExpression",
              "name": "String"
            },
            {
              "type": "NameExpression",
              "name": "Array"
            }
          ]
        },
        "name": "interval"
      },
      {
        "title": "param",
        "description": "the note to transpose",
        "lineNumber": 15,
        "type": {
          "type": "UnionType",
          "elements": [
            {
              "type": "NameExpression",
              "name": "String"
            },
            {
              "type": "NameExpression",
              "name": "Array"
            }
          ]
        },
        "name": "note"
      },
      {
        "title": "returns",
        "description": "the note transposed",
        "lineNumber": 16,
        "type": {
          "type": "UnionType",
          "elements": [
            {
              "type": "NameExpression",
              "name": "String"
            },
            {
              "type": "NameExpression",
              "name": "Array"
            }
          ]
        }
      },
      {
        "title": "example",
        "description": "var transpose = require('note-transposer')\ntranspose('3m', 'C4') // => 'Eb4'\ntranspose('C4', '3m') // => 'Eb4'\ntranpose([1, 0, 2], [3, -1, 0]) // => [3, 0, 2]\n['C', 'D', 'E'].map(transpose('3M')) // => ['E', 'F#', 'G#']",
        "lineNumber": 18
      },
      {
        "title": "kind",
        "kind": "function"
      }
    ],
    "loc": {
      "start": {
        "line": 5,
        "column": 0
      },
      "end": {
        "line": 28,
        "column": 3
      }
    },
    "context": {
      "loc": {
        "start": {
          "line": 29,
          "column": 0
        },
        "end": {
          "line": 37,
          "column": 0
        }
      },
      "file": "./packages/note-transposer/index.js",
      "code": "var parse = require('music-notation/pitch/parse')\nvar str = require('music-notation/pitch/str')\nvar operation = require('music-notation/operation')(parse, str)\n\n/**\n * Transposes a note by an interval.\n *\n * Given a note and an interval it returns the transposed note. It can be used\n * to add intervals if both parameters are intervals.\n *\n * The order of the parameters is indifferent.\n *\n * This function is currified so it can be used to map arrays of notes.\n *\n * @name transpose\n * @function\n * @param {String|Array} interval - the interval. If its false, the note is not\n * transposed.\n * @param {String|Array} note - the note to transpose\n * @return {String|Array} the note transposed\n *\n * @example\n * var transpose = require('note-transposer')\n * transpose('3m', 'C4') // => 'Eb4'\n * transpose('C4', '3m') // => 'Eb4'\n * tranpose([1, 0, 2], [3, -1, 0]) // => [3, 0, 2]\n * ['C', 'D', 'E'].map(transpose('3M')) // => ['E', 'F#', 'G#']\n */\nvar transpose = operation(function (i, n) {\n  if (i === false) return n\n  else if (!Array.isArray(i) || !Array.isArray(n)) return null\n  else if (i.length === 1 || n.length === 1) return [n[0] + i[0]]\n  var d = i.length === 2 && n.length === 2 ? null : n[2] || i[2]\n  return [n[0] + i[0], n[1] + i[1], d]\n})\n\nif (typeof module === 'object' && module.exports) module.exports = transpose\nif (typeof window !== 'undefined') window.transpose = transpose\n"
    },
    "name": "transpose",
    "params": [
      {
        "title": "param",
        "description": "the interval. If its false, the note is not\ntransposed.",
        "lineNumber": 13,
        "type": {
          "type": "UnionType",
          "elements": [
            {
              "type": "NameExpression",
              "name": "String"
            },
            {
              "type": "NameExpression",
              "name": "Array"
            }
          ]
        },
        "name": "interval"
      },
      {
        "title": "param",
        "description": "the note to transpose",
        "lineNumber": 15,
        "type": {
          "type": "UnionType",
          "elements": [
            {
              "type": "NameExpression",
              "name": "String"
            },
            {
              "type": "NameExpression",
              "name": "Array"
            }
          ]
        },
        "name": "note"
      }
    ],
    "returns": [
      {
        "title": "returns",
        "description": "the note transposed",
        "lineNumber": 16,
        "type": {
          "type": "UnionType",
          "elements": [
            {
              "type": "NameExpression",
              "name": "String"
            },
            {
              "type": "NameExpression",
              "name": "Array"
            }
          ]
        }
      }
    ],
    "examples": [
      "<span class=\"hljs-keyword\">var</span> transpose = <span class=\"hljs-built_in\">require</span>(<span class=\"hljs-string\">'note-transposer'</span>)\ntranspose(<span class=\"hljs-string\">'3m'</span>, <span class=\"hljs-string\">'C4'</span>) <span class=\"hljs-comment\">// =&gt; 'Eb4'</span>\ntranspose(<span class=\"hljs-string\">'C4'</span>, <span class=\"hljs-string\">'3m'</span>) <span class=\"hljs-comment\">// =&gt; 'Eb4'</span>\ntranpose([<span class=\"hljs-number\">1</span>, <span class=\"hljs-number\">0</span>, <span class=\"hljs-number\">2</span>], [<span class=\"hljs-number\">3</span>, -<span class=\"hljs-number\">1</span>, <span class=\"hljs-number\">0</span>]) <span class=\"hljs-comment\">// =&gt; [3, 0, 2]</span>\n[<span class=\"hljs-string\">'C'</span>, <span class=\"hljs-string\">'D'</span>, <span class=\"hljs-string\">'E'</span>].map(transpose(<span class=\"hljs-string\">'3M'</span>)) <span class=\"hljs-comment\">// =&gt; ['E', 'F#', 'G#']</span>"
    ],
    "kind": "function",
    "members": {
      "instance": [],
      "static": []
    },
    "events": [],
    "path": [
      "transpose"
    ]
  }
]